#!/usr/bin/env bash

#-----------------------------------------------------------------------------
# Get bash helper functions
source call_bashhelper

#-----------------------------------------------------------------------------
# Create help text
function Usage {
    cat <<USAGE

---------------------------------------------------------------------------------------------------
call_checksegmentations

Loads in all segmentations present in the manual_masks/<subject>/<ses-?> directory. Saves a bunch
of clicks. Assumes you've ran the pipeline with all settings set to default (e.g., the paths)

Args:
  -s <subject>  subject ID
  -n <session>  session number

Usage:
  call_checksegmentations -s <subject> -n 1

Example:
  call_checksegmentations -s sub-001 -n 1

---------------------------------------------------------------------------------------------------

USAGE

}

if [[ $# -lt 1 ]] ; then
  Usage && exit 0
fi

# Check for subject & session flags
while getopts s:n: argument
do
  case ${argument} in
    s)  sub=${OPTARG}
          ;;
    n)  ses=${OPTARG}
          ;;
  esac
done

#-----------------------------------------------------------------------------
# collect subject name
read base_path base <<< "$(collect_session_info "$ses" "$sub")"

#-----------------------------------------------------------------------------
# Run it

declare -a SEG=(
  "label-GM"
  "label-WM"
  "label-CSF"
  "cruise_cortex"
  "ribbon_wm"
  "ribbon_gm"
  "ribbon_mask"
  "cruise_mask"

)
ARRAY=()
j=0
for r in ${SEG[@]}; do
  file=$(find "${MASKS}/${base_path}" -type f \( -name "*${r}*" -and -name "*.nii.gz" \) 2>/dev/null)
  if [[ -f ${file} ]]; then

    if [[ ${j} -eq 0 ]]; then
        ADD_SEG=$(echo "-o ${file}")
    else
        ADD_SEG=$(echo " ${file}")
    fi
    ARRAY+=("${ADD_SEG}")
    ((j++))
  else
    echo "${sub}: Could not find \"${r}\" image in directory"
  fi
done

ANAT=$(find "${DIR_DATA_DERIV}/cat12/${base_path}" -type f \( -name "${sub}*" -and -name "*T1w.nii.gz" \) 2>/dev/null)
cmd=(
  launch_itksnap
  -g "${ANAT}"
  "${ARRAY[@]}"
)
print_cmd "${cmd[@]}" && eval "${cmd[@]}"  

