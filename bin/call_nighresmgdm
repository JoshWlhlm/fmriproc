#!/usr/bin/env python

try:
    from nighres.brain import mgdm_segmentation
except Exception:
    raise ImportError(f"Could not import 'nighres'.. Please install")

import sys, getopt
import os
import nibabel as nb
from fmriproc import image
from lazyfmri import utils
from pathlib import Path
opj = os.path.join
rb = utils.color.RED+utils.color.BOLD
gb = utils.color.GREEN+utils.color.BOLD
end = rb = utils.color.END

def main(argv):

    r"""
---------------------------------------------------------------------------------------------------
call_nighresmgdm

Estimates brain structures from an atlas for MRI data using a Multiple Object Geometric Deformable
Model (MGDM).

This script needs at least a T1-weighted image and a T1-map. Other options described as below can be
included, but if they are omitted then the script will default to the output directory it finds in
os.environ['NIGHRES'] as defined in the spinoza_setup script with name 'sub-xxx-space-mp2rage_desc'.
Because Nighres like everything in RAS-coordinates, the script will temporarily flip your axes to
conform this need (it really will go bad if it is not RAS), but also swaps the orientation to the
original upon completion. Mind you, that if an error occurs AFTER this re-orientating, the files
will have RAS!!

Args:
    -t|--t1w        File representing the T1-weighted image
    -m|--t1map      File representing the T1map
    -s|--skull      File representing the skull mask
    -d|--dura       File representing the dura mask
    -o|--outputdir  output directory (default is opj(os.getcwd(), 'mgdm'))
    -n|--name       basename for output (default is "subject_acq-MP2RAGE_desc")
    -i|--inputdir   automatically search for files in the 'skullstripped'-directory. This would be the out-
                    put generated by 'spinoza_masking', and should have the following
                    suffixes:

                    ```
                    pattern_map = {
                        "T1w": "T1w.nii.gz",
                        "T1map": "T1map.nii.gz",
                    }
                    ```

                    For instance, the input for a typical call could will look like this (generally
                    the output of 'spinoza_masking', which applies the brain mask to T1w/T1map files
                    to create skullstripped files):

                    ```
                    # only T1w/T1map files available
                    project_path/derivatives/skullstripped/sub-01/ses-1
                    ├── sub-01_ses-1_acq-MP2RAGE_desc-skullstrip_T1map.nii.gz
                    └── sub-01_ses-1_acq-MP2RAGE_desc-skullstrip_T1w.nii.gz
                    ```

    -p|--priors     The algorithm accepts 4 input files, each representing a different prior. In any
                    case, we need a T1w and T1map-file, which can come from different sources (e.g.,
                    field strength, atlases, or sequence). These sources include:
                    ['DWIFA3T', 'DWIMD3T', 'T1map9T', 'Mp2rage9T', 'T1map7T', 'Mp2rage7T', 'PV',
                    'Filters', 'T1pv', 'Mprage3T', 'T1map3T', 'Mp2rage3T', 'HCPT1w', 'HCPT2w',
                    'NormMPRAGE'].

                    For each input file, one of these sources must be specified. By default, the
                    priors are set to:
                    
                    ```
                    prior_list = [
                        "Mp2rage7T",
                        "T1map7T",
                        "Filters",
                        "Filters"
                    ]
                    ```

                    where:
                        - T1w-file (-t|--t1w) comes from a 7T MP2RAGE sequence
                        - T1map-file (-m|--t1map) comes from a 7T MP2RAGE sequence
                        - Mask representing the skull (-s|--skull) is a "Filters"
                        - Mask representing the dura (-d|--dura) is a "Filters"

    -x|--kwargs     Extra arguments that will be directly passed to 'cruise_cortex_extraction' (see
                    docs-link below for details). The format should be as follows: different para-
                    meters comma-separated, and parameter-value pair separated by '='):
                    
                    "-x <parameter1>=<value1>,<parameter2>=<value2>,<parameterX>=<valueX>"

                    E.g.,:
                    "-x regularization_weight=0.05,max_iterations=1000,normalize_probabilities=True"

                    This input will be parsed to a dictionary via 'lazyfmri.utils.parse_kwargs_to_dict()'
                    The kwargs specified in this flag take precedent over the default kwargs:

                    ```
                    defaults = {
                        "overwrite": True,
                        "save_data": True,
                        "output_dir": "directory specified with -o|--outputdir",
                        "file_name": "basename specified with -n|--name"
                    }
                    ```
Outputs
    taken from https://nighres.readthedocs.io/en/latest/brain/mgdm_segmentation.html
    Dictionary collecting outputs under the following keys (suffix of output files in brackets)

    segmentation (niimg):   Hard brain segmentation with topological constraints (if chosen)
                            (_mgdm_seg)
    labels (niimg):         Maximum tissue probability labels (_mgdm_lbls)
    memberships (niimg):    Maximum tissue probability values, 4D image where the first dimension
                            shows each voxel's highest probability to belong to a specific tissue, 
                            the second dimension shows the second highest probability to belong to 
                            another tissue etc. (_mgdm_mems)
    distance (niimg):       Minimum distance to a segmentation boundary (_mgdm_dist)


Example:
    call_nighresmgdm \
        -t t1w.nii.gz.nii.gz \
        -m t1map.nii.gz \
        -s skull_mask.nii.gz \
        -d dura_mask.nii.gz \
        -o derivatives/nighres/mgdm \
        -n subject_ses-1_acq-MP2RAGE_desc

    call_nighresmgdm -t t1w.nii.gz.nii.gz -m t1map.nii.gz
    call_nighresmgdm -i /dir/containing/anatomical/files

---------------------------------------------------------------------------------------------------
    """

    t1w = None
    t1map = None
    skull = None
    dura = None
    input_dir = None
    output_dir = opj(os.getcwd(), 'mgdm')
    output_base = "subject_acq-MP2RAGE_desc"
    prior_list = [
        "Mp2rage7T",
        "T1map7T",
        "Filters",
        "Filters"
    ]
    kwargs = {}

    try:
        opts = getopt.getopt(argv,"ht:m:s:d:o:b:i:x:p:n:",["help", "t1w=", "t1map=", "skull=", "dura=", "outputdir=", "name=", "inputdir=", "kwargs=", "priors="])[0]
    except getopt.GetoptError:
        print(main.__doc__)
        sys.exit(2)

    for opt, arg in opts:
        if opt == ("-h", "--help"):
            print(main.__doc__)
            sys.exit()
        elif opt in ("-t", "--t1w"):
            t1w = arg
        elif opt in ("-m", "--t1map"):
            t1map = arg
        elif opt in ("-s", "--skull"):
            skull = arg
        elif opt in ("-d", "--dura"):
            dura = arg
        elif opt in ("-o", "--outputdir"):
            output_dir = arg
        elif opt in ("-n", "--name"):
            output_base = arg
        elif opt in ("-i", "--inputdir"):
            input_dir = arg  
        elif opt in ("-p", "--priors"):
            prior_list = arg
        elif opt in ("-x", "--kwargs"):
            kwargs = utils.parse_kwargs_to_dict(arg)

    required_args = 2
    if (
        len(argv) < required_args
        or not isinstance(input_dir, str)
        or not os.path.isdir(input_dir)
        ):

        print("\nERROR: Missing or invalid arguments.")
        if len(argv) < required_args:
            print(" - Not enough command-line arguments specified.")
        if not isinstance(input_dir, str):
            print(" - Input directory is not a string.")
        elif not os.path.isdir(input_dir):
            print(f" - Input directory '{input_dir}' does not exist.")

        print(main.__doc__)
        sys.exit(1)

    #---------------------------------------------------------------------------------------------------
    # Collect files depending on whether we got an input directory or not
    print("Loading files..")
    files = {}
    pattern_map = {
        "T1w": "T1w.nii.gz",
        "T1map": "T1map.nii.gz",
        "skull": "skull_mask.nii.gz",
        "dura": "dura_mask.nii.gz"
    }
    if input_dir is not None:
        # we got passed an input_dir, fetch files from directory

        print(f"Loading files from {gb}{input_dir}{end}..")
        for key, pattern in pattern_map.items():
            in_file = utils.get_file_from_substring(pattern, input_dir, return_msg=None)
            input_kws[key] = in_file
    else:
        print("Loading manually specified files..")
        for key, val in zip(
            list(pattern_map),
            [t1w, t1map, skull, dura]
        ):
            input_kws[key] = val

    #---------------------------------------------------------------------------------------------------
    # Check that input files exist
    required_keys = ["T1w", "T1map"]
    for key in required_keys:
        if not files.get(key) or not os.path.isfile(files[key]):
            print(f"ERROR: Required file '{rb}{key}{end}' is missing or does not exist: {gb}{files.get(key)}{end}")
            sys.exit(1)

    optional_keys = set(files.keys()) - set(required_keys)
    for key in optional_keys:
        if not files[key] or not os.path.isfile(files[key]):
            del files[key]

    [print(f" {key}: {gb}{val}{end}") for key, val in files.items()]

    #---------------------------------------------------------------------------------------------------
    # temporarily reorient to RAS
    print("Checking orientation..")

    orig = {}
    init_files = {}
    for i in files:

        ax  = nb.aff2axcodes(nb.load(files[i]).affine, labels=(('R', 'L'), ('A', 'P'), ('S', 'I')))
        orig[i] = ax[0]+ax[1]+ax[2]
        ras = ('R','A','S')#temp_code
        lpi = ('L','P','I')#nb.as_closest_canonical (= RAS+, also seems to work with MGDM)
        code = ras[0].lower()+ras[1].lower()+ras[2].lower()

        if not ax == ras and not ax == lpi:
            orient = True
            image.reorient_img(files[i], code=code, out=files[i].split('.')[0]+f"_{code}-valid.nii.gz")
            init_files[i] = files[i].split('.')[0]+f"_{code}-valid.nii.gz"
        else:
            orient = False
            init_files[i] = files[i]

    print("Initialization (i.e., orienting) done. Starting procedure..")

    #---------------------------------------------------------------------------------------------------
    # Default kwargs
    defaults = {
        "save_data": True,
        "overwrite": True,
        "output_dir": output_dir,
        "file_name": output_base        
    }

    for key, val in defaults.items():
        kwargs = utils.update_kwargs(
            kwargs,
            key,
            val
        )

    # Build dynamic argument dict
    mgdm_args = {
        "contrast_image1": init_files["T1w"],
        "contrast_type1": prior_list[0],
        "contrast_image2": init_files["T1map"],
        "contrast_type2": prior_list[1],
    }

    if "dura" in init_files:
        if len(prior_list)<3:
            raise ValueError(f"List of priors is <3 ({len(prior_list)}), so I cannot derive what type of file this is..")

        mgdm_args["contrast_image3"] = init_files["dura"]
        mgdm_args["contrast_type3"] = prior_list[2]

    if "skull" in init_files:
        if len(prior_list)<3:
            raise ValueError(f"List of priors is <4 ({len(prior_list)}), so I cannot derive what type of file this is..")

        mgdm_args["contrast_image4"] = init_files["skull"]
        mgdm_args["contrast_type4"] = prior_list[3]

    # combine input & kwargs
    combined_kwargs = {**mgdm_args, **kwargs}

    #---------------------------------------------------------------------------------------------------
    # Run MGDM
    results = mgdm_segmentation(**combined_kwargs)

    #---------------------------------------------------------------------------------------------------
    # Reorient results back to original orientation (if reorientation was done)
    if orient:
        print("Reorienting results to original orientation")
        for result_name, result_path in results.items():
            try:
                # Determine which original input this result came from (fallback to first input)
                reference_key = list(orig.keys())[0]
                orig_code = orig.get(reference_key, 'RAS')

                image.reorient_img(result_path, code=orig_code)
            except Exception as e:
                print(f"Warning: Failed to reorient result '{result_name}': {e}")

        print("Cleaning up temporary reoriented inputs")
        for key, file_path in ras_files.items():
            if file_path.endswith(f"{code}-valid.nii.gz"):
                try:
                    os.remove(file_path)
                except Exception as e:
                    print(f"  Warning: Could not remove {file_path}: {e}")

    #---------------------------------------------------------------------------------------------------
    # Nicer formatting of output filenames
    output_path = Path(output_dir)
    suffixes = ["seg", "dist", "lbls", "mems"]

    for suffix in suffixes:
        old_name = output_path / f"{output_base}_mgdm-{suffix}.nii.gz"
        new_name = output_path / f"{output_base}-mgdm_{suffix}.nii.gz"

        if old_name.exists():
            try:
                print(f"Renaming: {old_name.name} → {gb}{new_name.name}{end}")
                old_name.rename(new_name)
            except Exception as e:
                print(f"Warning: Could not rename {old_name.name}: {e}")
        else:
            print(f"File not found: {rb}{old_name.name}{end}")
            
    print("Done")

if __name__ == "__main__":
    main(sys.argv[1:])
