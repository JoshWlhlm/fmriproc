#!/usr/bin/env python

try:
    from nighres.brain import mgdm_segmentation
except Exception:
    raise ImportError(f"Could not import 'nighres'.. Please install")

import os
import sys
import getopt
import nibabel as nb
from fmriproc import image
from lazyfmri import utils
opj = os.path.join
rb = f"{utils.color.RED}{utils.color.BOLD}"
gb = f"{utils.color.GREEN}{utils.color.BOLD}"
end = utils.color.END

@utils.validate_cli_inputs(required_keys=["T1w", "T1map"], allow_input_dir=True)
def main(context):

    r"""
---------------------------------------------------------------------------------------------------
call_nighresmgdm

Estimates brain structures from an atlas for MRI data using a Multiple Object Geometric Deformable
Model (MGDM). This script needs at least a T1-weighted image and a T1-map. Other options described 
as below can be included, but if they are omitted then the script will default to the output 
directory it finds in os.environ.get('NIGHRES') as defined in the \$CONFIG_FILE with name 
'sub-xxx-space-mp2rage_desc'. Because Nighres like everything in RAS-coordinates, the script will 
temporarily flip your axes to conform this need (it really will go bad if it is not RAS), but also 
swaps the orientation to the original upon completion. Mind you, that if an error occurs AFTER 
this re-orientating, the files will have RAS!! The conversion to nifti implemented in 'spinoza_
scanner2bids' automatically ensures the files are in the correct coordinate system.

Mandatory (required input):
  -t|--t1w        File representing the T1-weighted image
  -m|--t1map      File representing the T1map

  OR:
  -i|--inputdir   automatically search for files in the 'skullstripped'-directory. This would be
                  the output generated by 'spinoza_masking', and should have the following
                  suffixes:

                  pattern_map = {
                    "T1w": "T1w.nii.gz",            # mandatory
                    "T1map": "T1map.nii.gz",        # mandatory
                    "skull": "skull_mask.nii.gz",   # optional
                    "dura": "dura_mask.nii.gz"      # optional
                  }

                  For instance, the input for a typical call could will look like this (generally
                  the output of 'spinoza_masking', which applies the brain mask to T1w/T1map files
                  to create skullstripped files):

                  # only T1w/T1map files available
                  project_path/derivatives/skullstripped/sub-01/ses-1
                  ├── sub-01_ses-1_acq-MP2RAGE_desc-skullstrip_T1map.nii.gz
                  └── sub-01_ses-1_acq-MP2RAGE_desc-skullstrip_T1w.nii.gz

Optional (flags with defaults):
  -s|--skull      File representing the skull mask
  -d|--dura       File representing the dura mask
  -o|--outputdir  output directory (default is opj(os.getcwd(), 'mgdm'))
  -n|--name       basename for output (default is "subject_acq-MP2RAGE_desc")

  -p|--priors     The algorithm accepts 4 input files, each representing a different prior. In any
                  case, we need a T1w and T1map-file, which can come from different sources (e.g.,
                  field strength, atlases, or sequence). These sources include:
                  ['DWIFA3T', 'DWIMD3T', 'T1map9T', 'Mp2rage9T', 'T1map7T', 'Mp2rage7T', 'PV',
                  'Filters', 'T1pv', 'Mprage3T', 'T1map3T', 'Mp2rage3T', 'HCPT1w', 'HCPT2w',
                  'NormMPRAGE'].

                  For each input file, one of these sources must be specified. By default, the
                  priors are set to:
                  
                  prior_list = [
                    "Mp2rage7T",
                    "T1map7T",
                    "Filters",
                    "Filters"
                  ]

                  where:
                    - T1w-file (-t|--t1w) comes from a 7T MP2RAGE sequence
                    - T1map-file (-m|--t1map) comes from a 7T MP2RAGE sequence
                    - Mask representing the skull (-s|--skull) is a "Filters"
                    - Mask representing the dura (-d|--dura) is a "Filters"

                  Format should be comma-separated list for the number of inputs used. For the
                  regular version, this means 4 (T1w, T1map, skull, and dura). For GdH-version,
                  this means 2 (T1w, T1map):

                    E.g., "-p Mprage3T,T1map3T,Filters,Filters"

  -x|--kwargs     Extra arguments that will be directly passed to 'mgdm_segmentation' (see
                  docs-link below for details). The format should be as follows: different para-
                  meters comma-separated, and parameter-value pair separated by '='):
                  
                    "-x <parameter1>=<value1>,<parameter2>=<value2>,<parameterX>=<valueX>"

                  E.g.,:
                    "-x regularization_weight=0.05,max_iterations=1000"

                  This input will be parsed to a dictionary via 'lazyfmri.utils.
                  parse_kwargs_to_dict()'. The kwargs specified in this flag take precedent over 
                  the default kwargs:

                  defaults = {
                    "overwrite": True,
                    "save_data": True,
                    "output_dir": "directory specified with -o|--outputdir",
                    "file_name": "basename specified with -n|--name"
                  }

Options (extra):
  -h|--help       print this help text

Outputs
  segmentation (niimg):   Hard brain segmentation with topological constraints (if chosen)
                          (-mgdm_seg)
  labels (niimg):         Maximum tissue probability labels (-mgdm_lbls)
  memberships (niimg):    Maximum tissue probability values, 4D image where the first dimension
                          shows each voxel's highest probability to belong to a specific tissue, 
                          the second dimension shows the second highest probability to belong to 
                          another tissue etc. (-mgdm_mems)
  distance (niimg):       Minimum distance to a segmentation boundary (-mgdm_dist)


Example:
  # simple call
  call_nighresmgdm -t t1w.nii.gz.nii.gz -m t1map.nii.gz

  # include filters
  call_nighresmgdm \
    -t t1w.nii.gz.nii.gz \
    -m t1map.nii.gz \
    -s skull_mask.nii.gz \
    -d dura_mask.nii.gz \
    -o derivatives/nighres/mgdm \
    -n subject_ses-1_acq-MP2RAGE_desc

  # use input directory
  call_nighresmgdm -i /dir/containing/anatomical/files

Notes:
  docs: https://nighres.readthedocs.io/en/latest/brain/mgdm_segmentation.html

--------------------------------------------------------------------------------------------------
    """

    t1w = context.get("T1w")
    t1map = context.get("T1map")
    skull = context.get("skull")
    dura = context.get("dura")
    input_dir = context.get("input_dir")
    output_dir = context.get("output_dir", opj(os.getcwd(), 'mgdm'))
    output_base = context.get("output_base", "subject_acq-MP2RAGE_desc")
    prior_list = context.get("prior_list", ["Mp2rage7T", "T1map7T", "Filters", "Filters"])
    kwargs = context.get("kwargs", {})

    #-----------------------------------------------------------------------------
    # Collect files depending on whether we got an input directory or not
    files = {}
    pattern_map = {
        "T1w": "T1w.nii.gz",
        "T1map": "T1map.nii.gz",
        "skull": "skull_mask.nii.gz",
        "dura": "dura_mask.nii.gz"
    }

    if input_dir is not None:
        # we got passed an input_dir, fetch files from directory

        print(f"Loading files from {gb}{input_dir}{end}..")
        for key, pattern in pattern_map.items():
            in_file = utils.get_file_from_substring(pattern, input_dir, return_msg=None)
            files[key] = in_file
    else:
        print("Loading manually specified files..")
        for key, val in zip(
            list(pattern_map),
            [t1w, t1map, skull, dura]
        ):
            files[key] = val

    #-----------------------------------------------------------------------------
    # Check that input files exist
    required_keys = ["T1w", "T1map"]
    for key in required_keys:
        if not files.get(key) or not os.path.isfile(files[key]):
            print(f"ERROR: Required file '{rb}{key}{end}' is missing or does not exist: {gb}{files.get(key)}{end}")
            sys.exit(1)

    optional_keys = set(files.keys()) - set(required_keys)
    for key in optional_keys:
        if not files[key] or not os.path.isfile(files[key]):
            del files[key]

    [print(f" {key}: {gb}{val}{end}") for key, val in files.items()]

    #-----------------------------------------------------------------------------
    # temporarily reorient to RAS
    print("Checking orientation...")
    orig = {}
    init_files = {}
    orient = False

    for i in files:
        ax = nb.aff2axcodes(nb.load(files[i]).affine, labels=(('R', 'L'), ('A', 'P'), ('S', 'I')))
        orig[i] = "".join(ax)
        ras = ('R','A','S')
        lpi = ('L','P','I')
        code = ''.join(ras).lower()

        if not ax == ras and not ax == lpi:
            orient = True
            reoriented_file = files[i].split('.')[0]+f"_{code}-valid.nii.gz"
            image.reorient_img(files[i], code=code, out=reoriented_file)
            init_files[i] = reoriented_file
        else:
            init_files[i] = files[i]

    print("Initialization (i.e., orienting) done. Starting procedure...")

    #-----------------------------------------------------------------------------
    # Default kwargs
    defaults = {
        "save_data": True,
        "overwrite": True,
        "output_dir": output_dir,
        "file_name": output_base
    }

    for key, val in defaults.items():
        kwargs = utils.update_kwargs(kwargs, key, val)

    # Build dynamic argument dict
    mgdm_args = {
        "contrast_image1": init_files["T1w"],
        "contrast_type1": prior_list[0],
        "contrast_image2": init_files["T1map"],
        "contrast_type2": prior_list[1]
    }

    if "dura" in init_files:
        mgdm_args["contrast_image3"] = init_files["dura"]
        mgdm_args["contrast_type3"] = prior_list[2]

    if "skull" in init_files:
        mgdm_args["contrast_image4"] = init_files["skull"]
        mgdm_args["contrast_type4"] = prior_list[3]

    combined_kwargs = {**mgdm_args, **kwargs}

    #-----------------------------------------------------------------------------
    # Run MGDM
    results = mgdm_segmentation(**combined_kwargs)

    utils.run_shell_wrapper('bash -c "source call_bashhelper && print_line -"')
    print()

    #-----------------------------------------------------------------------------
    # Reorient results back to original orientation (if reorientation was done)
    if orient:
        print("Reorienting results to original orientation")
        for result_name, result_path in results.items():
            try:
                reference_key = list(orig.keys())[0]
                orig_code = orig.get(reference_key, 'RAS')
                image.reorient_img(result_path, code=orig_code)
            except Exception as e:
                print(f"Warning: Failed to reorient result '{result_name}': {e}")

    #-----------------------------------------------------------------------------
    # Rename file to BIDS style
    print("Rename to more BIDS'ey style")
    suffixes = ["seg", "dist", "lbls", "mems"]

    for suffix in suffixes:
        fn_old = os.path.join(output_dir, f"{output_base}_mgdm_{suffix}.nii.gz")
        fn_new = os.path.join(output_dir, f"{output_base}-mgdm_{suffix}.nii.gz")
        if os.path.exists(fn_old):
            print(f" {os.path.basename(fn_old)} → {gb}{os.path.basename(fn_new)}{end}")
            os.rename(fn_old, fn_new)

    print("Done")

if __name__ == "__main__":
    t1w = None
    t1map = None
    skull = None
    dura = None
    input_dir = None
    output_dir = opj(os.getcwd(), 'mgdm')
    output_base = "subject_acq-MP2RAGE_desc"
    prior_list = ["Mp2rage7T", "T1map7T", "Filters", "Filters"]
    kwargs = {}

    try:
        opts = getopt.getopt(
            sys.argv[1:],
            "ht:m:s:d:o:b:i:x:p:n:",
            ["help", "t1w=", "t1map=", "skull=", "dura=", "outputdir=", "name=", "inputdir=", "kwargs=", "priors="]
        )[0]
    except getopt.GetoptError:
        print(main.__doc__, flush=True)
        print("ERROR while handling arguments.. Did you specify an 'illegal' argument..?", flush=True)
        sys.exit(2)

    for opt, arg in opts:
        if opt in ("-h", "--help"):
            print(main.__doc__)
            sys.exit()
        elif opt in ("-t", "--t1w"):
            t1w = arg
        elif opt in ("-m", "--t1map"):
            t1map = arg
        elif opt in ("-s", "--skull"):
            skull = arg
        elif opt in ("-d", "--dura"):
            dura = arg
        elif opt in ("-o", "--outputdir"):
            output_dir = arg
        elif opt in ("-n", "--name"):
            output_base = arg
        elif opt in ("-i", "--inputdir"):
            input_dir = arg
        elif opt in ("-p", "--priors"):
            prior_list = [i.strip() for i in arg.split(",")] if "," in arg else [arg.strip()]
        elif opt in ("-x", "--kwargs"):
            kwargs = utils.parse_kwargs_to_dict(arg)

    main(context={
        "T1w": t1w,
        "T1map": t1map,
        "skull": skull,
        "dura": dura,
        "input_dir": input_dir,
        "output_dir": output_dir,
        "output_base": output_base,
        "prior_list": prior_list,
        "kwargs": kwargs
    })
