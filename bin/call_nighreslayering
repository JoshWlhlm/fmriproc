#!/usr/bin/env python

try:
    from nighres.laminar import volumetric_layering
except Exception:
    raise ImportError(f"Could not import 'nighres'.. Please install")

import sys, getopt
from lazyfmri import utils
import os
from pathlib import Path
opj = os.path.join
rb = utils.color.RED+utils.color.BOLD
gb = utils.color.GREEN+utils.color.BOLD
end = rb = utils.color.END

def main(argv):

    r"""
---------------------------------------------------------------------------------------------------
call_nighreslayering

Equivolumetric layering of the cortical sheet using output of CRUISE. You will need to specify the
path to the GM/WM boundary, the CSF/GM boundary, the number of layers to extract, the output direc-
tory, and the base output name (e.g., "sub-001_desc")

Args:
    -i|--inner      File representing the inner boundary (GM/WM boundary [GWB])
    -o|--outer      File representing the outer boundary (CSF/GM boundary [CGB])
    -l|--layers     number of layers to extract (default = 10)
    -o|--outputdir  output directory (default is opj(os.getcwd(), 'layering'))
    -n|--name       basename for output (default is "subject_acq-MP2RAGE_desc")
    -p|--inputdir   automatically search for files in the 'CRUISE'-directory. This would be the out-
                    put generated by 'call_nighrescruise', and should have the following
                    suffixes:

                    ```
                    pattern_map = {
                        "inner_levelset": "gwb.nii.gz",
                        "outer_levelset": "cgb.nii.gz",
                    }
                    ```

                    The output from CRUISE will typically have these files:

                    ```
                    project_path/derivatives/nighres/sub-01/ses-1/cruise
                    ├── sub-01_ses-1_acq-MP2RAGE_desc-gwb.nii.gz
                    └── sub-01_ses-1_acq-MP2RAGE_desc-cgb.nii.gz
                    ```

    -x|--kwargs     Extra arguments that will be directly passed to 'volumetric_layering' (see
                    docs-link below for details). The format should be as follows: different para-
                    meters comma-separated, and parameter-value pair separated by '='):
                    
                    "-x <parameter1>=<value1>,<parameter2>=<value2>,<parameterX>=<valueX>"

                    E.g.,:
                    "-x layer_dir='inward',curv_scale=5"

                    This input will be parsed to a dictionary via 'lazyfmri.utils.parse_kwargs_to_dict()'
                    The kwargs specified in this flag take precedent over the default kwargs:

                    ```
                    defaults = {
                        "save_data": True,
                        "n_layers": "number of layers specified with -l|--layers",
                        "output_dir": "directory specified with -o|--outputdir",
                        "file_name": "basename specified with -n|--name"
                    }
                    ```
Outputs:
    (taken from https://nighres.readthedocs.io/en/latest/laminar/volumetric_layering.html)
    Dictionary collecting outputs under the following keys (suffix of output files in brackets)

    depth (niimg):      Continuous depth from 0 (inner surface) to 1 (outer surface) (-layering_
                        depth)
    layers (niimg):     Discrete layers from 1 (bordering inner surface) to n_layers (bordering
                        outer surface)
                        (-layering_layers)
    boundaries (niimg): Levelset representations of boundaries between all layers in 4D (-layer-
                        ing_boundaries)

Example:
    call_nighreslayering \
        -i sub-001_ses-1_acq-MP2RAGE_desc-cruise_gwb.nii.gz \
        -o sub-001_ses-1_acq-MP2RAGE_desc-cruise_cgb.nii.gz \
        -l 4 \
        -d derivatives/nighres/sub-001/layering \
        -n sub-001_ses-1_acq-MP2RAGE_desc

---------------------------------------------------------------------------------------------------

    """

    inner = None
    outer = None
    nr_layers = 10
    output_dir = opj(os.getcwd(), 'layering')
    output_base = "subject_acq-MP2RAGE_desc"
    kwargs = {}

    try:
        opts = getopt.getopt(argv,"hi:o:l:d:n:x:p:",["help", "inner=", "outer=", "layers=", "outputdir=", "name=", "kwargs=", "inputdir="])[0]
    except getopt.GetoptError:
        print(main.__doc__)
        print("ERROR IN ARGUMENTS")
        sys.exit(2)

    for opt, arg in opts:
        if opt == ("-h", "--help"):
            print(main.__doc__)
            sys.exit()
        elif opt in ("-i", "--inner"):
            inner = arg
        elif opt in ("-o", "--outer"):
            outer = arg
        elif opt in ("-l", "--layers"):
            nr_layers = int(arg)
        elif opt in ("-d", "--outputdir"):
            output_dir = arg
        elif opt in ("-n", "--name"):
            output_base = arg
        elif opt in ("-x", "--kwargs"):
            kwargs = utils.parse_kwargs_to_dict(arg)
        elif opt in ("-p", "--inputdir"):
            input_dir = arg  
            
    required_args = 2
    if (
        len(argv) < required_args
        or not isinstance(input_dir, str)
        or not os.path.isdir(input_dir)
        ):

        print("\nERROR: Missing or invalid arguments.")
        if len(argv) < required_args:
            print(" - Not enough command-line arguments specified.")
        if not isinstance(input_dir, str):
            print(" - Input directory is not a string.")
        elif not os.path.isdir(input_dir):
            print(f" - Input directory '{input_dir}' does not exist.")

        print(main.__doc__)
        sys.exit(1)

    #---------------------------------------------------------------------------------------------------
    # Collect files depending on whether we got an input directory or not
    print("Loading files..")
    pattern_map = {
        "inner_levelset": "gwb.nii.gz",
        "outer_levelset": "cgb.nii.gz",
    }

    input_kws = {}
    if input_dir is not None:
        # we got passed an input_dir, fetch files from directory

        print(f"Loading files from {gb}{input_dir}{end}..")
        for key, pattern in pattern_map.items():
            in_file = utils.get_file_from_substring(pattern, input_dir, return_msg=None)
            input_kws[key] = in_file
    else:
        print("Loading manually specified files..")
        for key, val in zip(
            list(pattern_map),
            [inner, outer]
        ):
            input_kws[key] = val

    #---------------------------------------------------------------------------------------------------
    # Check that input files exist
    for key in list(pattern_map):
        if not files.get(key) or not os.path.isfile(files[key]):
            print(f"ERROR: Required file '{rb}{key}{end}' is missing or does not exist: {gb}{files.get(key)}{end}")
            sys.exit(1)

    [print(f" {key}: {gb}{val}{end}") for key, val in input_kws.items()]

    #---------------------------------------------------------------------------------------------------
    # Default kwargs
    defaults = {
        "save_data": True,
        "overwrite": True,
        "n_layers": nr_layers,
        "output_dir": output_dir,
        "file_name": output_base        
    }

    for key, val in defaults.items():
        kwargs = utils.update_kwargs(
            kwargs,
            key,
            val
        )

    # combine input & kwargs
    combined_kwargs = {**input_kws, **kwargs}

    #---------------------------------------------------------------------------------------------------
    # run layering
    volumetric_layering(**combined_kwargs)

    #---------------------------------------------------------------------------------------------------
    # Nicer formatting of output filenames
    output_path = Path(output_dir)
    suffixes = ["depth", "layers", "boundaries"]

    for suffix in suffixes:
        old_name = output_path / f"{output_base}_layering-{suffix}.nii.gz"
        new_name = output_path / f"{output_base}-layering_{suffix}.nii.gz"

        if old_name.exists():
            try:
                print(f"Renaming: {old_name.name} → {gb}{new_name.name}{end}")
                old_name.rename(new_name)
            except Exception as e:
                print(f"Warning: Could not rename {old_name.name}: {e}")
        else:
            print(f"File not found: {rb}{old_name.name}{end}")

    print("Done")

if __name__ == "__main__":
    main(sys.argv[1:])
