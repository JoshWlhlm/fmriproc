#!/usr/bin/env python

import os
import numpy as np
from nilearn import image
import nibabel as nb
from lazyfmri import utils
import sys
opj = os.path.join


def resample_and_convert_to_mgh(
    src,
    trg,
    **kwargs
    ):

    kwargs = utils.update_kwargs(
        kwargs,
        "interpolation",
        "nearest"
    )

    # resample to FreeSurfer
    res  = image.resample_to_img(
        src,
        trg, 
        **kwargs
    )
    
    # read into MGH
    res_mgh = nb.freesurfer.MGHImage(
        res.get_fdata().astype(np.float32),
        affine=res.affine
    )

    return res_mgh

@validate_cli_inputs(required_keys=["subject", "wmseg"])
def main(subject=None, wmseg=None, cortex=None):
    """
---------------------------------------------------------------------------------------------------
call_fixwm

The white-matter segmentation from FreeSurfer is not always optimal. With the script we inject the
segmentation from CAT12 into FreeSurfer, which is much more accurate, especially around insular re-
gions. We just give it the FreeSurfer subject and the path to CAT12's white matter segmentation. I
tried inserting the CAT12 segmentation as manualsegwm in call_gdhinject, but then you get similar
cerebellum issues.

Arguments:
    <subject>       subject ID as used in the FreeSurfer directory
    <WM seg>        path to WM-segmentation from CAT12
    <cortex seg>    path to cortex mask to eliminate cerebellum > created during spinoza_cortexre-
                    construction

Example:
    call_fixwm sub-999 /path/to/p2WMseg.nii.gz /path/to/cortexseg.nii.gz

---------------------------------------------------------------------------------------------------
    """

    subject = None
    wmseg   = None
    cortex  = None

    if len(argv) < 2:
        print(main.__doc__)
        sys.exit()

    subject, wmseg = argv[:2]
    cortex = argv[2] if len(argv) > 2 else None
    
    # define FreeSurfer path
    fsdir = opj(os.environ.get("SUBJECTS_DIR"), subject)
    if not os.path.exists(fsdir):
        raise ValueError(f"Could not find {subject} in SUBJECTS_DIR. Is it set correctly?")
    
    # find WM
    fswm = opj(fsdir, 'mri', 'wm.mgz')
    if not os.path.exist(fswm):
        raise FileNotFoundError(f"Could not find {fswm}-file. Did FreeSurfer run properly?")

    # define CRUISE file
    if cortex is None:
        cortex = utils.get_file_from_substring(
            "cruise_mask", 
            opj(
                os.environ.get("DIR_DATA_DERIV"),
                "manual_masks",
                subject,
                "ses-1"
            )
        )

    # Resample CAT12/nighres segmentations to match FreeSurfer's white matter image
    catwm = resample_and_convert_to_mgh(
        wmseg,
        fswm
    )

    cortex = resample_and_convert_to_mgh(
        cortex,
        fswm
    )

    # Create manual white matter mask within cortex
    manual_mask = image.math_img(
        '(a * b) > 0',
        a=catwm,
        b=cortex
    )

    # Combine FreeSurfer and manual white matter masks
    fs_wm_combined = image.math_img(
        '(a + b) > 0',
        a=fswm,
        b=manual_mask
    )

    # Convert to binary mask with label 110
    fs_wm_labeled = image.math_img('a * 110', a=fs_wm_combined)

    # Keep only the largest connected component
    largest = image.largest_connected_component_img(fs_wm_labeled)
    largest = nb.MGHImage(
        largest.get_data(),
        fs_wm_labeled.affine,
        fs_wm_labeled.header
    )

    # Apply the largest component mask
    image.math_img(
        'a * b',
        a=fs_wm_labeled,
        b=largest
    ).to_filename(opj(fsdir, 'mri', 'wm.mgz'))

if __name__ == "__main__":

    # Defaults
    context = {
        "subject": None,
        "wmseg": None,
        "cortex": None
    }

    # Parse args
    argv = sys.argv[1:]
    if len(argv) < 2:
        print(main.__doc__)
        sys.exit()

    # Unpack mandatory arguments
    context["subject"] = argv[0]
    context["wmseg"]   = argv[1]

    # Optional 3rd arg
    if len(argv) > 2:
        context["cortex"] = argv[2]

    # Run main with unpacked context
    main(**context)
