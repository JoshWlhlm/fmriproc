#!/usr/bin/env bash

#---------------------------------------------------------------------------------------------------------
# source helper functions
source ${SETUP_FILE}
source call_bashhelper

#---------------------------------------------------------------------------------------------------------
# extra functions
construct_bids_filename() {
  local bold="$1"
  local bids_dir="$2"
  local image="$3"
  local base="$4"
  local run="$5"
  local ext="$6"
  local count="$7"

  # Determine task
  local task
  task=$(task_id "${bold}")
  if [[ -z ${task} ]]; then
    task=${TASK_IDS[0]:-stim}
  fi

  # Get desc and acq
  local desc acq add_acq
  [[ "${bold}" == *"desc"* ]] && desc=$(get_id "${bold}" desc)
  acq=$(get_id "${bold}" acq)

  if [[ -n ${acq} ]]; then
    add_acq="_acq-${acq}"
    [[ -n ${desc} ]] && add_acq+="${desc}"
  elif [[ -n ${desc} ]]; then
    add_acq="_acq-${desc}"
  else
    add_acq=""
  fi

  # fetch run
  run=`run_id ${bold}`
  if [[ ${run} -eq 0 ]]; then
    run=${count}
  fi 

  # Construct final filename
  echo "${bids_dir}/${image}/${base}_task-${task}_run-${run}${add_acq}${ext}"
}

# trim volumes
maybe_trim_volumes() {
  local ff="$1"
  local image="$2"
  local cut_vols="$3"
  local trim_fmap="$4"

  if [[ "${cut_vols}" -gt 0 ]]; then
    if [[ "${image}" == "func" || "${image}" == "phase" || ( "${image}" == "fmap" && "${trim_fmap}" -eq 1 ) ]]; then
      local n_vols
      n_vols=$(fslval "${ff}" dim4 | xargs)

      if [[ "$n_vols" -gt "${cut_vols}" ]]; then
        local tmp_file
        tmp_file="$(dirname "${ff}")/tmp.nii.gz"

        echo "  Trimming first ${cut_vols} volumes (originally ${n_vols} volumes)..."
        fslroi "${ff}" "${tmp_file}" "${cut_vols}" -1 && mv "${tmp_file}" "${ff}"
      else
        echo "  Skipping trim: ${ff} has only ${n_vols} volumes (cut_vols=${cut_vols})"
      fi
    fi
  fi
}

maybe_reorient() {
  local input="$1"
  local reorient="$2"
  if [[ ${reorient} -eq 1 ]]; then
    call_reorient -i ${input}
  fi
}

handle_json_metadata() {
  local orig="$1" ff="$2" image="$3" set_tr="$4" skip_tr="$5" pe_dir="$6" idx="$7"

  local json_file json_bids
  json_file="$(dirname "${orig}")/$(basename "${orig}" .nii.gz).json"
  json_bids="$(dirname "${ff}")/$(basename "${ff}" .nii.gz).json"

  [[ ! -f ${json_file} ]] && return 0
  cp "${json_file}" "${json_bids}"

  ensure_intended_for "${json_bids}" "${image}" "${idx}"
  enrich_with_par_data "${json_bids}" "${ff}" "${set_tr}" "${skip_tr}" "${image}"
  set_pe_direction "${json_bids}" "${image}" "${pe_dir}"
}

rel_path() {
  local input="${1}"
  local base_path=""
  if [[ $(basename "${input}") == *"ses"* ]]; then
    base_path="$(basename "${input}" | cut -d"_" -f2)/"
  fi
  echo "${base_path}"
}

ensure_intended_for() {
  local json_bids="$1" image="$2" idx="$3"

  if [[ ${image} != "fmap" ]]; then return; fi

  if ! grep -q "IntendedFor" "${json_bids}"; then
    local base_path=$(rel_path ${json_bids})
    local intended_for="${base_path}func/$(basename "${json_bids}" _epi.json)_bold.nii.gz"
    local b0_id="pepolar_$(printf "%02d" "${idx}")"

    call_json "${json_bids}" IntendedFor "${intended_for}"
    call_json "${json_bids}" B0FieldIdentifier "${b0_id}"
  fi
}

enrich_with_par_data() {
  local json_bids="$1" ff="$2" set_tr="$3" skip_tr="$4" image="$5"

  local par_f ext tr tr_hd mb_factor scan_mode n_slices
  par_f=$(read_json "${json_bids}" ParFile)
  [[ -z ${par_f} ]] && return

  ext=$(fetch_extension "${par_f}")
  local ext_lower=$(echo "$ext" | tr '[:upper:]' '[:lower:]')

  if [[ ${ext_lower} == *"par"* ]]; then
    echo -e "  Storing information from ${BOLD_RED}$(basename "${par_f}")${RESET} in json file"
    pars_for_json --merge "${par_f}" "${json_bids}"
  fi

  tr_hd=$(fslval "${ff}" pixdim4 | xargs)
  if [[ -z ${set_tr} ]]; then
    if [[ ${ext_lower} == *"par"* ]]; then
      tr=$(tr_from_par "${par_f}")
    else
      tr=$(read_dcm "${par_f}" RepetitionTime)
    fi
    echo -e "  TR in $(basename "${par_f}") is ${BOLD_RED}${tr}${RESET}s"
  else
    tr=${set_tr}
    echo -e "  TR manually specified with '-t ${BOLD_RED}${tr}${RESET}'; setting RepetitionTime"
  fi

  [[ -n ${tr} ]] && call_json "${json_bids}" RepetitionTime "${tr}"

  # TR correction
  if [[ ${skip_tr} -eq 0 ]]; then
    if (( $(echo "${tr_hd} == 0.0" | bc -l) )); then
      echo -e "  WARNING: TR is zero — correcting to ${BOLD_RED}${tr}${RESET}"
      call_settr "${ff}" "${tr}" || exit 1
    elif (( $(echo "${tr_hd} != ${tr}" | bc -l) )); then
      echo -e "  WARNING: TR mismatch (file=${BOLD_RED}${tr_hd}${RESET}, json=${BOLD_RED}${tr}${RESET}) — correcting"
      call_settr "${ff}" "${tr}" || exit 1
    else
      echo -e "  TR in header [${BOLD_RED}${tr_hd}${RESET}] matches specified value [${BOLD_RED}${tr}${RESET}]"
    fi
  elif (( $(echo "${tr_hd} != ${tr}" | bc -l) )); then
    echo -e "  WARNING: TR mismatch (file=${tr_hd}, json=${tr}), but ${BOLD_RED}--skip-tr${RESET} is used"
  fi

  # Slice timing (only for non-3D func)
  [[ ${image} == "phase" ]] && return

  if [[ ${ext_lower} == *"par"* ]]; then 
    scan_mode=$(read_par "${par_f}" "Scan mode")
  else
    scan_mode=$(read_dcm "${par_f}" "MRAcquisitionType")
  fi

  [[ ${scan_mode} == "3D" ]] && return

  mb_factor=$(read_json "${json_bids}" MultiBandAccelerationFactor)
  if [[ -z ${mb_factor} ]]; then
    mb_factor=3
    echo -e "  WARNING: Defaulting to multiband factor ${BOLD_RED}3${RESET} — override with 'export MB_FACTOR=...'"
  fi

  tr=$(read_json "${json_bids}" RepetitionTime)
  if [[ ${ext_lower} == *"par"* ]]; then
    n_slices=$(read_par "${par_f}" "Max. number of slices/locations")
  else
    n_slices=$(read_dcm "${par_f}" "NumberOfImagesInMosaic")
  fi

  call_slicetiming "${json_bids}" "${tr}" "${n_slices}" "${mb_factor}" || {
    echo "ERROR: call_slicetiming failed"
    exit 1
  }
}

set_pe_direction() {
  local json_bids="$1" image="$2" pe_dir="$3"

  local ph_dir txt ext_lower par_f pe_from_dcm pe_dir_from_file

  # read from filename
  pe_dir_from_file=$(get_id "${json_bids}" "dir")
  if [[ ! -z ${pe_dir_from_file} ]]; then
    ph_dir=$(fprep_pe ${pe_dir_from_file})
    txt="Read PhaseEncodingDirection from ${BOLD_RED}filename${RESET}"
  else
    # try other options
    par_f=$(read_json "${json_bids}" ParFile)
    [[ -n ${par_f} ]] && ext_lower=$(fetch_extension "${par_f}" | tr '[:upper:]' '[:lower:]')

    if [[ -n ${pe_dir} ]]; then
      ph_dir=$(fprep_pe "${pe_dir}" $([[ ${image} == "fmap" ]] && echo "1"))
      txt="PE-direction set with '${BOLD_RED}--${pe_dir}${RESET}'"
    elif [[ -n ${par_f} && ${ext_lower} == *"dcm"* ]]; then
      pe_from_dcm=$(pe_from_dcm "${par_f}")
      if [[ -n ${pe_from_dcm} ]]; then
        txt="PE-direction from ${BOLD_RED}DICOM${RESET}: ${pe_from_dcm}"
        if [[ ${image} == "fmap" ]]; then
          # Invert for fmap
          case "${pe_from_dcm}" in
            j) ph_dir="j-" ;;
            j-) ph_dir="j" ;;
            i) ph_dir="i-" ;;
            i-) ph_dir="i" ;;
          esac
          txt="${txt} (inverted for fmap)"
        else
          ph_dir="${pe_from_dcm}"
        fi
      fi
    else
      # Try reading existing PhaseEncodingDirection
      ph_dir=$(read_json "${json_bids}" PhaseEncodingDirection)
      [[ -n ${ph_dir} ]] && txt="Read PhaseEncodingDirection from ${BOLD_RED}JSON${RESET}"
    fi

    # Fallback default
    if [[ -z ${ph_dir} ]]; then
      if [[ ${image} == "fmap" ]]; then
        ph_dir="j-"
      elif [[ ${image} == "func" ]]; then
        ph_dir="j"
      fi
      txt="${BOLD_RED}Default${RESET} PE-direction: \"${BOLD_RED}${ph_dir}${RESET}\""
    fi
  fi

  if [[ -n ${ph_dir} ]]; then
    echo -e "  WARNING: ${txt}"
    echo -e "  PE-direction for ${image^^}=\"${BOLD_RED}${ph_dir}${RESET}\" — confirm or set with 'PE_DIR_BOLD' or flag"
    call_json "${json_bids}" PhaseEncodingDirection "${ph_dir}"
  else
    echo "  WARNING: Could not derive PE-direction — please set PE_DIR_BOLD or use a direction flag"
  fi
}

process_lowres_mp2rage() {
  local input_dir="$1"
  local bids_dir="$2"
  local base="$3"
  local ls_ses="$4"

  if [[ ${ls_ses} -ne 1 ]]; then return; fi

  local anat_lowres anat_t1map min acq acq_flag

  anat_lowres=$(find -L "${input_dir}/planning/nifti" -type f \( -name "*real*" -a -name "*t10*" -a -name "*.nii.gz" -o -name "*acq-3DFFE*" -a -name "*.nii.gz" \) 2>/dev/null)
  anat_t1map=$(find -L "${input_dir}/planning/nifti" -type f \( -name "*real*" -a -name "*t29*" -a -name "*.nii.gz" \) 2>/dev/null)

  if [[ -n ${anat_lowres} ]]; then

    [[ ! -d "${bids_dir}/anat" ]] && mkdir -p "${bids_dir}/anat"

    if [[ -f ${anat_t1map} ]]; then
      min=$(fslstats "${anat_lowres}" -R | awk '{print $1}')
      if [[ ${min} != "0.000000" ]]; then
        echo " Rescaling lowres MP2RAGE-file"
        call_maskmp2rage "${anat_lowres}" "${anat_t1map}" "${anat_lowres}"
      fi
    fi

    acq=$(get_id "${anat_lowres}" acq)
    [[ -z ${acq} ]] && acq="MP2RAGE"
    acq_flag="_acq-${acq}"

    echo " Relocating lowres MP2RAGE-file as ${base}${acq_flag}_T1w.nii.gz"

    cp "${anat_lowres}" "${bids_dir}/anat/${base}${acq_flag}_T1w.nii.gz"

    local json_file
    json_file="$(dirname "${anat_lowres}")/$(basename "${anat_lowres}" .nii.gz).json"
    if [[ -f "${json_file}" ]]; then
      cp "${json_file}" "${bids_dir}/anat/${base}${acq_flag}_T1w.json"
    else
      echo "  WARNING: Could not find JSON sidecar for ${anat_lowres}"
    fi

  else
    echo " low resolution MP2RAGE exists"
  fi
}

process_anatomical_inversions() {
  local tmp_dir="$1"
  local bids_dir="$2"
  local base="$3"
  local DATA="$4"
  local OW="$5"
  local reorient="$6"

  echo " Processing anatomical images..."

  local invs=()
  while IFS= read -r f; do invs+=("$f"); done < <(find -L "${tmp_dir}" -type f \( -name "*inv-*" -a -name "*.nii.gz" \) 2>/dev/null | sort)

  if [[ ${#invs[@]} -gt 0 ]]; then
    [[ ! -d "${bids_dir}/anat" ]] && mkdir -p "${bids_dir}/anat"

    for ff in "${invs[@]}"; do
      local rec_tag inv_tag ext out_fn

      if [[ $(basename "${ff}") == *"_ph_"* || $(basename "${ff}") == *"phase"* ]]; then
        rec_tag="part-phase"
      else
        rec_tag="part-mag"
      fi

      if [[ $(basename "${ff}") == *"t10"* || $(basename "${ff}") == *"inv-1"* ]]; then
        inv_tag="inv-1"
      else
        inv_tag="inv-2"
      fi

      ext=$(fetch_extension "${ff}")
      [[ ${ext} == "gz" ]] && ext="nii.gz"

      out_fn="${bids_dir}/anat/${base}_acq-${DATA}_${inv_tag}_${rec_tag}.${ext}"

      if [[ ! -f "${out_fn}" || ${OW} -eq 1 ]]; then
        echo -e "  Renaming $(basename "${ff}") to ${BOLD_GREEN}${out_fn}${RESET}"
        cp "${ff}" "${out_fn}"

        # reorient to LPI
        maybe_reorient "$ff" "$reorient"
      fi
    done

  else
    # No inv-* files, check for pre-reconstructed files (e.g., from call_complex)
    local parts=()
    while IFS= read -r f; do parts+=("$f"); done < <(find -L "${tmp_dir}" -type f \( -name "*part-mag*" -o -name "*part-phase*" \) 2>/dev/null | sort)

    if [[ ${#parts[@]} -gt 0 ]]; then
      [[ ! -d "${bids_dir}/anat" ]] && mkdir -p "${bids_dir}/anat"
      echo "  Copying pre-reconstructed part-mag/phase files to anat/"
      cp "${parts[@]}" "${bids_dir}/anat"
    fi
  fi
}

process_search_anatomicals() {
  local tmp_dir="$1"
  local bids_dir="$2"
  local base="$3"
  local OW="$4"
  local reorient="$5"

  for qq in "${SEARCH_ANATOMICALS[@]}"; do
    local img
    img=$(find -L "${tmp_dir}" -type f -name "*${qq}.nii.gz" 2>/dev/null)

    if [[ -n ${img} ]]; then
      local acq run acq_tag run_tag out_fn json_fn

      acq=$(get_id "${img}" acq)
      [[ -n ${acq} ]] && acq_tag="_acq-${acq}" || acq_tag=""

      run=$(get_id "${img}" run)
      [[ -n ${run} ]] && run_tag="_run-${run}" || run_tag=""

      [[ ! -d "${bids_dir}/anat" ]] && mkdir -p "${bids_dir}/anat"

      out_fn="${bids_dir}/anat/${base}${acq_tag}${run_tag}_${qq}.nii.gz"
      if [[ ! -f "${out_fn}" || ${OW} -eq 1 ]]; then
        echo -e "  Renaming $(basename "${img}") to ${BOLD_GREEN}${out_fn}${RESET}"
        cp "${img}" "${out_fn}" 2>/dev/null

        # reorient to LPI
        maybe_reorient "$out_fn" "$reorient"
      fi

      json_fn="$(dirname "${img}")/$(basename "${img}" .nii.gz).json"
      if [[ -f "${json_fn}" ]]; then
        cp "${json_fn}" "$(dirname "${out_fn}")/$(basename "${out_fn}" .nii.gz).json" 2>/dev/null
      fi
    fi
  done
}

process_motion_images() {
  local tmp_dir="$1"
  local bids_dir="$2"
  local base="$3"
  local OW="$4"

  local motion_img=()
  while IFS= read -r f; do motion_img+=("$f"); done < <(find -L "${tmp_dir}" -type f -name "*motion*" -a -name "*.nii.gz" 2>/dev/null | sort)

  echo " Relocating multi-slice file (${#motion_img[@]})"

  for i in "${motion_img[@]}"; do
    local run fname json_src json_dst

    run=$(get_id "${i}" motion)
    [[ -z ${run} ]] && run="${i}"

    fname="${bids_dir}/anat/${base}_acq-MP2RAGE_rec-motion${run}.nii.gz"

    if [[ ! -f "${fname}" || ${OW} -eq 1 ]]; then
      if [[ -f "${i}" ]]; then
        echo -e "  Renaming to ${BOLD_GREEN}$(basename "${fname}")${RESET}"
        cp "${i}" "${fname}"

        json_src="$(dirname "${i}")/$(basename "${i}" .nii.gz).json"
        json_dst="$(dirname "${fname}")/$(basename "${fname}" .nii.gz).json"

        if [[ -f "${json_src}" ]]; then
          cp "${json_src}" "${json_dst}"
        else
          echo "  WARNING: JSON sidecar not found for ${i}"
        fi
      else
        echo "  WARNING: Could not locate motion file: ${i}"
      fi
    else
      echo "  $(basename "${fname}") exists"
    fi
  done
}

process_single_slice_anatomicals() {
  local tmp_dir="$1"
  local bids_dir="$2"
  local base="$3"
  local OW="$4"

  local slice_img=()
  while IFS= read -r f; do slice_img+=("$f"); done < <(
    find -L "${tmp_dir}" -type f \
      -name "*1slice*" \
      -a ! -name "*space*" \
      -a -name "*anat*" \
      -a -name "*.nii.gz" 2>/dev/null | sort
  )

  local count=0

  if [[ ${#slice_img[@]} -gt 0 ]]; then
    echo " Found \"acq-1slice\" files"

    for slice in "${slice_img[@]}"; do
      ((count++))

      local run task_id task_flag bids_slice json_src json_dst

      run=$(run_id "${slice}")
      [[ ${run} -eq 0 ]] && run="${count}"

      task_id=$(get_id "${slice}" task)
      [[ -n ${task_id} ]] && task_flag="_task-${task_id}" || task_flag=""

      bids_slice="${bids_dir}/anat/${base}${task_flag}_run-${run}_acq-1slice_T1w.nii.gz"

      if [[ ! -f "${bids_slice}" || ${OW} -eq 1 ]]; then
        if [[ -f "${slice}" ]]; then
          echo -e "  Renaming to ${BOLD_GREEN}$(basename "${bids_slice}")${RESET}"
          cp "${slice}" "${bids_slice}"

          json_src="$(dirname "${slice}")/$(basename "${slice}" .nii.gz).json"
          json_dst="$(dirname "${bids_slice}")/$(basename "${bids_slice}" .nii.gz).json"

          if [[ -f "${json_src}" ]]; then
            cp "${json_src}" "${json_dst}"
          else
            echo "  WARNING: No JSON sidecar for ${slice}"
          fi
        fi
      else
        echo "  $(basename "${bids_slice}") exists"
      fi
    done

  else
    echo "  WARNING: no \"1slice\"-files were found in ${tmp_dir}"
  fi
}

process_linescanning_bold_lab() {
  local input_dir="$1"
  local bids_dir="$2"
  local tmp_dir="$3"
  local base="$4"
  local OW="$5"
  local sub_name="$6"

  local bold_files=()
  while IFS= read -r f; do bold_files+=("$f"); done < <(
    find -L "${input_dir}" -type f -name "*bold_*" -a -name "*.lab" 2>/dev/null | sort
  )

  if [[ ${#bold_files[@]} -eq 0 ]]; then
    echo "  WARNING: no \"bold*.lab\"-files were found in ${input_dir}"
    return
  fi

  [[ ! -d "${bids_dir}/func" ]] && mkdir -p "${bids_dir}/func"
  echo " Found line-scanning bold-files (*.lab)"

  # Determine foldover direction
  local info_file
  info_file=$(find -L "${DIR_DATA_DERIV}/pycortex/${sub_name}" -type f -name "*desc-info*.csv" 2>/dev/null)
  local fold="FH"
  [[ -f ${info_file} ]] && fold=$(grep -A0 "foldover" "${info_file}" | cut -d',' -f3)
  echo -e "  foldover is set to: ${BOLD_RED}${fold}${RESET}"

  # Find 1slice template for run-1
  local slice_img=()
  while IFS= read -r f; do slice_img+=("$f"); done < <(
    find -L "${bids_dir}/anat" -type f \
      -name "${base}*" -a -name "*1slice*" -a -name "*run-1*" -a -name "*.nii.gz" 2>/dev/null
  )

  local ct=0
  for ii in "${slice_img[@]}"; do ((ct++)); done
  if [[ ${ct} -gt 1 ]]; then
    echo "  WARNING: multiple matching [\"acq-1slice\" and \"run-1\"] files found — using first"
  fi
  local slice_template="${slice_img[0]}"

  local count=0
  for bold in "${bold_files[@]}"; do
    ((count++))

    local run task par_file fileparts line_img

    run=$(get_id "${bold}" run)
    [[ -z ${run} || ${run} -eq 0 ]] && run=${count}

    task=$(get_id "${bold}" task)
    [[ -z ${task} ]] && task=${TASK_IDS[0]}
    [[ ${task} == "prf" ]] && task="pRF"
    [[ ${task} == "sr" ]] && task="SR"

    # Try to get more accurate task label from corresponding .par file
    par_file=$(find -L "$(dirname "${bold}")" -type f -name "*run-${run}*" -a -name "*task-${task}*" -a -name "*bold*" -a -iname "*.par" 2>/dev/null)
    if [[ -f ${par_file} ]]; then
      fileparts=$(read_par "${par_file}" "Protocol name")
      task=$(get_id "${fileparts}" task)
    fi

    line_img="${bids_dir}/func/${base}_task-${task}_run-${run}_bold.nii.gz"

    if [[ -f ${slice_template} ]]; then
      if [[ ! -f ${line_img} || ${OW} -eq 1 ]]; then
        call_createline \
          -i "${slice_template}" \
          -o "${line_img}" \
          --width 16 \
          --"${fold,,}"

        if [[ $? -ne 0 ]]; then
          echo
          print_line -
          echo -e "${BOLD_RED}ERROR${RESET} in $(basename "$0"): call_createline exited with non-zero status"
          exit 1
        fi

        echo -e "  wrote ${BOLD_GREEN}$(basename "${line_img}")${RESET}"
      else
        echo "  $(basename "${line_img}") exists"
      fi
    else
      echo "  WARNING: could not find slice template (1slice, run-1) in ${bids_dir}/anat"
    fi
  done
}

fix_final_intendedfor() {
  local bids_dir="$1"

  local func_files fmap_files funcs=() fmaps=()

  # Get and sort BOLD and FMAP files
  func_files=()
  while IFS= read -r line; do func_files+=("$line"); done < <(
    find -L "${bids_dir}/func" -type f -name "*_bold.nii.gz" | sort
  )

  fmap_files=()
  while IFS= read -r line; do fmap_files+=("$line"); done < <(
    find -L "${bids_dir}/fmap" -type f -name "*_epi.json" | sort
  )

  # Filter out line-scanning BOLDs (dim0 > 3)
  for ff in "${func_files[@]}"; do
    local dim0
    dim0=$(fslval "${ff}" dim0)
    if [[ ${dim0} -gt 3 ]]; then
      funcs+=("${ff}")
    fi
  done

  fmaps=("${fmap_files[@]}")

  local num_funcs="${#funcs[@]}"
  local num_fmaps="${#fmaps[@]}"

  if [[ ${num_funcs} -ne ${num_fmaps} ]]; then

    if [[ ${num_fmaps} -eq 1 && ${num_funcs} -gt 1 ]]; then
      echo -e "${BOLD_RED}1${RESET} FMAP for ${BOLD_RED}all${RESET} BOLDs — applying IntendedFor and B0FieldIdentifier"

      local func_list=""
      for i in "${!funcs[@]}"; do
        local base_path=$(rel_path ${funcs[$i]})
        local rel_path="${base_path}func/$(basename ${funcs[$i]})"
        func_list+="${rel_path}"
        [[ $i -lt $((num_funcs - 1)) ]] && func_list+=","
        
        local json_func="${funcs[$i]%.nii.gz}.json"
        [[ -f ${json_func} ]] && call_json "${json_func}" B0FieldSource "pepolar_01"
      done

      call_json "${fmaps[0]}" IntendedFor "${func_list}"
      call_json "${fmaps[0]}" B0FieldIdentifier "pepolar_01"

    elif [[ $((num_funcs / num_fmaps)) -eq 2 ]]; then
      echo -e "${BOLD_RED}1${RESET} FMAP per ${BOLD_RED}2${RESET} BOLDs — applying IntendedFor and B0FieldIdentifier"

      local fm_ct=0
      local fc=$((num_funcs / num_fmaps))
      local id=1

      for fmap in "${fmaps[@]}"; do
        local tmp_list=""
        local field_id="pepolar_$(printf "%02d" ${id})"

        for ((j = 0; j < fc; j++)); do
          local idx=$((fm_ct + j))
          local base_path=$(rel_path ${funcs[$i]})
          local rel_path="${base_path}func/$(basename ${funcs[$i]})"
          tmp_list+="${rel_path}"
          [[ $j -lt $((fc - 1)) ]] && tmp_list+=","

          # Set B0FieldSource on each BOLD JSON
          local json_func="${funcs[$idx]%.nii.gz}.json"
          [[ -f ${json_func} ]] && call_json "${json_func}" B0FieldSource "${field_id}"
        done

        call_json "${fmap}" IntendedFor "${tmp_list}"
        call_json "${fmap}" B0FieldIdentifier "${field_id}"

        fm_ct=$((fm_ct + fc))
        id=$((id + 1))
      done

    elif [[ $((num_funcs / num_fmaps)) -eq 1 ]]; then
      echo -e "${BOLD_RED}1${RESET} FMAP per BOLD — applying individual B0FieldIdentifiers"

      for i in "${!fmaps[@]}"; do
        local base_path=$(rel_path ${funcs[$i]})
        local rel_path="${base_path}func/$(basename ${funcs[$i]})"
        local field_id="pepolar_$(printf "%02d" $((i + 1)))"

        call_json "${fmaps[$i]}" IntendedFor "${rel_path}"

        # Set B0FieldSource on BOLD JSON
        local json_func="${funcs[$i]%.nii.gz}.json"
        [[ -f ${json_func} ]] && call_json "${json_func}" B0FieldSource "${field_id}"      
      done

    else
      local ratio=$((num_funcs / num_fmaps))
      echo "WARNING: got ${num_funcs} BOLD files and ${num_fmaps} FMAP files."
      echo "I can only handle:"
      echo " - 1 FMAP for all BOLDs"
      echo " - 1 FMAP per BOLD"
      echo " - 1 FMAP for every ${ratio} BOLDs"
    fi
  else
    echo "Number of BOLDs and FMAPs match — assuming already linked"
  fi
}

scrape_and_link_fieldmaps() {
  local tmp_dir="$1"
  local bids_dir="$2"
  local set_tr="$3"
  local skip_tr="$4"
  local cut_vols="$5"
  local trim_fmap="$6"
  local reorient="$7"

  local func_dir="${bids_dir}/func"
  local fmap_dir="${bids_dir}/fmap"

  [[ ! -d "${func_dir}" ]] && return
  [[ ! -d "${fmap_dir}" ]] && mkdir -p "${fmap_dir}"

  echo -e " Scanning for ${BOLD_RED}deviating PEPolar${RESET} fieldmaps in \"${tmp_dir}\""

  # Collect BOLD files
  local -a bolds=()
  while IFS= read -r bold; do bolds+=("${bold}"); done < <(
    find "${func_dir}" -type f -name "*_bold.nii.gz"
  )

  local fmap_count=0

  fmaps=($(find "${tmp_dir}" -type f -name "*_dir-*_epi.nii.gz" | sort 2>/dev/null))
  echo " Found ${#fmaps[@]} FMAP file(s)"
  idx=1
  for fmap_file in ${fmaps[@]}; do
    local fname=$(basename "${fmap_file}")
    local fmap_json="${fmap_file%.nii.gz}.json"
    local target_nii="${fmap_dir}/${fname}"
    local target_json="${fmap_dir}/$(basename "${fmap_json}")"

    # Move if not already in fmap_dir
    if [[ "${fmap_file}" != "${target_nii}" ]]; then
      echo -e " #${idx}: ${BOLD_GREEN}${fmap_file}${RESET}"
      cp "${fmap_file}" "${target_nii}" 2>/dev/null
      [[ -f "${fmap_json}" ]] && cp "${fmap_json}" "${target_json}" 2>/dev/null
    fi

    # cut volumes
    maybe_trim_volumes "$target_nii" "fmap" "$cut_vols" "$trim_fmap"

    # reorient to LPI
    maybe_reorient "$target_nii" "$reorient"

    # add data from PAR/DCM file
    enrich_with_par_data "${target_json}" "${target_nii}" "${set_tr}" "${skip_tr}" "fmap"

    # read PE-direction from filename
    set_pe_direction "${target_json}" "fmap"

    [[ ! -f "${target_json}" ]] && echo "  Missing JSON for ${fname}, skipping" && continue

    # Add IntendedFor if not present
    if ! grep -q "IntendedFor" "${target_json}"; then
      echo "  Adding IntendedFor to $(basename "${target_json}")"

      for bold in "${bolds[@]}"; do
        # macOS-compatible relative path fallback
        local rel_bold
        local base_path=$(rel_path ${bold})
        local rel_bold="${base_path}func/$(basename ${bold})"
        call_json "${target_json}" IntendedFor "${rel_bold}"
      done
    fi

    # Add unique B0FieldIdentifier if not present
    if ! grep -q "B0FieldIdentifier" "${target_json}"; then
      ((fmap_count++))
      local identifier="pepolar_$(printf "%02d" ${fmap_count})"
      echo "  Adding B0FieldIdentifier=${identifier}"
      call_json "${target_json}" B0FieldIdentifier "${identifier}"
    fi
  done
}

#-----------------------------------------------------------------------------
# Create help text
function Usage {
    cat <<EOF

---------------------------------------------------------------------------------------------------
call_bids

convert raw data from the scanner to nifti format. Depending on which session we're analyzing, we'll
use either call_dcm2niix (session 1 - which is FromScannerToBIDS from M. Aqil) which can deal
nicely with the anatomical and functional stuff or call_dcm2niix, which is more specific for the
line scanning stuff.

Mandatory inputs:
  -i <input dir>  directory containing the PAR-files
  -b <bids dir>   output directory for BIDSified data (generally DIR_DATA_HOME/<subject>/<session>)
  -n <base name>  output base name for BIDS files (e.g., sub-01_ses-1)                

Optional:
  -o <output dir> directory to store intermediate nifti files (defaults to <input dir>/nifti)
  -d <depth>      search depth for dcm2niix
  -t <TR>         set RepetitionTime for BOLD/EPI files. Default is to search for the TR using
                  tr_from_par/tr_from_dcm (in call_bashhelper). See those functions for more in-
                  formation on extracting RepetitionTime-key.
  -r <runs>       convert specific runs. Can be comma-separated list for multiple runs (e.g.,
                  "-r 1,3,4")
  -v <n_vols>     number of volumes to cut from the beginning of the timeseries (default = None)
                  For instance, you have acquired the actual data from dummy scans rather than
                  discard them.                      
  -p <pattern>    pattern for file-name reconstruction (default = %n_%p, representing Patient-
                  Name & Protocol Name). You can change this, but then I don't bear any respon-
                  sibilities over the consequences in later scripts.. This option is only avai-
                  lable for 'dcm2niix' (DCM-files), not 'parrec2nii' (PAR/REC-files).
  -a <suffixes>   use suffixes to store other anatomical files in the BIDS folder. This over-
                  writes the SEARCH_ANATOMICALS-variable in the setup-file. For instance, if 
                  you have qMRI-data that did not come from MP2RAGEME, you can specify:
                  "-a T2star,QSM,T1map". Input must be comma-separated without spaces. *.nii.gz
                  will be added to the search. 'acq' and 'run' tags are derived from the file-
                  name.

Options:
  -h|--help       print this help text
  --ow            overwrite existing files
  --lines         flag to tell we're dealing with a line-scanning session. By default 'regular',
                  which means standard whole-brain acquisitions.
  --inv           add individual inversion files from anatomies in 'anat' folder
  --take-avg-tr   Take the average over all TRs from the par file, rather than the first in the
                  sequence of TRs
  --ap            set phase-encoding direction for BOLD to AP (overwrite PE_DIR_BOLD-variable)
  --pa            set phase-encoding direction for BOLD to PA (overwrite PE_DIR_BOLD-variable)
  --lr            set phase-encoding direction for BOLD to LR (overwrite PE_DIR_BOLD-variable)
  --rl            set phase-encoding direction for BOLD to RL (overwrite PE_DIR_BOLD-variable)
  --no-lpi        do not reorient files to LPI. If you want to use NORDIC or use fMRIprep's out-
                  puts on more raw data, I'd advise you to reorient to LPI and to NOT use this 
                  flag. This flag is mainly here because it can take some time with big files
                  which slows down debugging.
  --phys          run only physiology conversion
  --skip-tr       do not overwrite the TR in the header during call_bids. Generally not recommen-
                  ded, but exists for debugging purposes.
  --skip-fmap     do not trim the time series from FMAPs. By default, it is assumed that all your
                  functional files have dummy-saving turned on.
  --no-compress   create nii's instead of nii.gz's (default). Passes on '--no-compress' to call-
                  parrec2nii, and '-c n' to dcm2niix
  --force-exec    Force execution even though converted nifti already exists (passed to parrec2nii)

Example:
  # simple call
  call_bids
    -i DIR_DATA_SOURCE/sub-02/ses-1          # input with par/rec files
    -b DIR_DATA_HOME/sub-02/ses-1            # BIDS output
    -n sub-02_ses-1                          # BIDS base name

  # also consider line-scanning files
  call_bids
    --lines
    -i DIR_DATA_SOURCE/sub-02/ses-1          # input with par/rec files
    -b DIR_DATA_HOME/sub-02/ses-1            # BIDS output
    -n sub-02_ses-1                          # BIDS base name

Notes:
  - MP2RAGE files will be selected on the presence of the following strings in the filename:
    - 'T1w_'; this must be somewhere in your sequence name
    - '_t10', '_t29', '_t30'; denote different trigger delays, will be appended by the dcm2niix conver-
      sion
    - Excludes files that have 'WIP' in them, as we're combining the inversion images with pymp2rage
  - FLAIR/T2w files will be selected on the presence of '{FLAIR|T2w}.nii.gz' in the filename

---------------------------------------------------------------------------------------------------------

EOF
    exit 1
}

#---------------------------------------------------------------------------------------------------------
# Deal with arguments

# Check for subject & session flags
ses_type="regular"
add_inv=0
reorient=1
tr_prot_flag=""
compress_flag="--compressed"
compress="-c o"
pe_dir=""
OW=0
phys_only=0
searchDepth=0
ls_ses=0
set_tr=""
skip_tr=0
cut_vols=0
trim_fmap=1
pattern_flag=""
include_anatomicals=""
kwargs=""
force_flag=""
while getopts :-:hi:o:b:n:r:d:t:v:p:a:c:x: argument
do
  case ${argument} in
    -)
      case "${OPTARG}" in
        lines)
          ses_type="lines"
          ls_ses=1
          ;;
        inv)
          add_inv=1
          ;;
        take-avg-tr)
          tr_prot_flag="--take-avg-tr"
          ;;      
        ap)
          pe_dir="AP"
          ;;          
        pa)
          pe_dir="PA"
          ;;         
        lr)
          pe_dir="LR"
          ;;         
        rl)
          pe_dir="RL"
          ;;
        no-lpi)
          reorient=0
          ;;    
        ow)
          OW=1
          ;;            
        phys)
          phys_only=1
          ses_type="lines"
          ;;
        skip-tr)
          skip_tr=1
          ;;           
        skip-fmap)
          trim_fmap=0
          ;;
        force-exec)
          force_flag="--force-exec"
          ;;          
        no-compress)
          compress="-c n"
          compress_flag=""
          ;;     
        help)
          Usage && exit 0
          ;;                         
        *)
          Usage
          print_error_msg "$(basename ${0})" "getopt" "Unknown option --${OPTARG}"
          exit 1
          ;;
      esac
      ;;   
    i)  input_dir=${OPTARG}
          ;;
    o)  tmp_dir=${OPTARG}
          ;;
    d)  searchDepth=${OPTARG}
          ;;            
    b)  bids_dir=${OPTARG}
          ;;
    n)  base=${OPTARG}
          ;;    
    r)  runs=${OPTARG}
          ;; 
    t)  set_tr=${OPTARG}
          ;;     
    v)  cut_vols=${OPTARG}
          ;; 
    p)  pattern_flag="-p ${OPTARG}"
          ;;
    a)  include_anatomicals="${OPTARG}"
          ;;  
    c)  compress="-c ${OPTARG}"
          ;;     
    x)  kwargs="-x ${OPTARG}"
          ;;                        
    h)  Usage
          ;;                                                           
  esac
done

if [[ $# -lt 3 ]] ; then
  Usage
fi

# sort out runs
if [[ ! -z ${runs} ]]; then
  # read specified subjects into array
  IFS=', ' read -r -a n_runs <<< "${runs}"
  unset IFS
fi

# sort out anatomicals
if [[ ! -z ${include_anatomicals} ]]; then
  # read specified subjects into array
  IFS=', ' read -r -a SEARCH_ANATOMICALS <<< "${include_anatomicals}"
  unset IFS
fi

# default tmp dir
if [[ -z ${tmp_dir} ]]; then
  tmp_dir=${input_dir}/nifti
fi

#-------------------------------------------------------------------------------------------------------------------------------
# PARREC TO NIFTI
if [[ -d ${tmp_dir} ]]; then
  if [[ -z "$(ls -A $tmp_dir)" ]]; then
    echo
    print_line -
    print_error_msg "$(basename ${0})" "find" "\"${tmp_dir}\" exists, but is empty. You probably need to change the search depth for dcm2niix with \"-d <depth>\" (now ${searchDepth}). Append \"--full -d <depth>\" to your call. "
    exit 1
  else
    echo "Directory exists, skipping conversion (use \"--full\" to overwrite this folder too)." 
  fi
else
  echo "Converting files to nifti-format"
  cmd=(
    call_dcm2niix
    "${force_flag}"
    "${pattern_flag}"    
    "${tr_prot_flag}"
    "${compress}"
    "${compress_flag}"
    "${kwargs}"
    -i "${input_dir}"
    -o "${tmp_dir}"
    -d "${searchDepth}"
  )
  
  print_cmd "${cmd[@]}" && eval "${cmd[@]}"

  if [[ $? -ne 0 ]]; then
    print_error_msg "$(basename ${0})" "call_dcm2niix"
    exit 1
  fi
fi

# check if we got something
if [[ -z "$(ls -A $tmp_dir)" ]]; then
  echo
  print_line -
  print_error_msg "$(basename ${0})" "find" "\"${tmp_dir}\" exists, but is empty."
  echo "You probably need to change the search depth for dcm2niix with \"-d <depth>\" (now ${searchDepth})."
  echo "Append \"--full -d <depth>\" to your call"
  echo "Check the log file: \"${input_dir}/log.txt\""
  exit 1
fi
  
echo "BIDSifying data .."

#-------------------------------------------------------------------------------------------------------------------------------
# NIFTI TO BIDS
if [[ ${phys_only} -eq 0 ]]; then

  # Low resolution anatomical scan
  process_lowres_mp2rage "$input_dir" "$bids_dir" "$base" "$ls_ses"

  #---------------------------------------------------------------------------------------------------------
  # anatomicals
  inv_files=0
  if [[ ${ls_ses} -eq 1 ]]; then
    if [[ ${add_inv} -eq 1 ]]; then
      inv_files=1
    fi
  else
    inv_files=1
  fi  

  if [[ ${inv_files} -eq 1 ]]; then

    # INV-images
    process_anatomical_inversions "$tmp_dir" "$bids_dir" "$base" "$DATA" "$OW" "$reorient"

    # SEARCH_ANATOMICALS=("T2w" "FLAIR" "T1w") in spinoza_setup
    process_search_anatomicals "$tmp_dir" "$bids_dir" "$base" "$OW" "$reorient"

  fi

  #---------------------------------------------------------------------------------------------------------
  # acq-motion files for line-scanning
  if [[ ${ls_ses} -eq 1 ]]; then

    if [[ ! -d ${bids_dir}/anat ]]; then
      mkdir -p ${bids_dir}/anat
    fi

    # Multi-slice files
    process_motion_images "$tmp_dir" "$bids_dir" "$base" "$OW"

    # Single-slice
    process_single_slice_anatomicals "$tmp_dir" "$bids_dir" "$base" "$OW"

    # line-scanning BOLD
    process_linescanning_bold_lab \
      "$input_dir" \
      "$bids_dir" \
      "$tmp_dir" \
      "$base" \
      "$OW" \
      "$sub_name"
  
  fi

  #---------------------------------------------------------------------------------------------------------
  # check for more whole-brainy stuff
  if [[ ${ls_ses} -eq 1 ]]; then
    # deal with stuff added by sequence development editor..
    sde=1

    if [[ ! -z ${runs} ]]; then
      b_files=()
      for r in ${n_runs[@]}; do
        run_f=$(find -L "${input_dir}" -type f \( -name "${base}*" -and -name "*run-${r}*" -and -iname "*acq-3DEPI*" -and -name "*bold*" -and -name "*.nii.gz" -and -not -name "*_ph.nii.gz" \) 2>/dev/null)
        b_files+=(${run_f})
      done
    else
      b_files=$(find -L "${input_dir}" -type f \( -name "${base}*" -and -iname "*acq-3DEPI*" -and -name "*bold*" -and -name "*.nii.gz" -and -not -name "*_ph.nii.gz" \) 2>/dev/null)
    fi

  else
    sde=0
    if [[ ! -z ${runs} ]]; then
      b_files=()
      for r in ${n_runs[@]}; do
        run_f=$(find -L "${input_dir}" -type f \( -name "${base}*" -and -name "*run-${r}*" -and -name "*bold.nii.gz" \) 2>/dev/null)
        b_files+=(${run_f})
      done
    else  
      b_files=$(find -L "${input_dir}" -type f \( -name "${base}*" -and -name "*bold.nii.gz" \) 2>/dev/null)
    fi
  fi

  # sort array (https://stackoverflow.com/questions/7442417/how-to-sort-an-array-in-bash)
  IFS=$'\n' bold_files=($(sort <<<"${b_files[*]}"))
  unset IFS

  count=0
  mb_warning=0
  pe_warning=0
  warning=0
  if [[ ! -z ${bold_files[@]} ]]; then

    echo " Found ${#bold_files[@]} BOLD file(s)"
    idx=1
    for bold in ${bold_files[@]}; do

      echo -e " #${idx}: ${BOLD_GREEN}${bold}${RESET}"

      func=${bold}
      phase=$(dirname ${bold})/$(basename ${bold} .nii.gz)_ph.nii.gz

      # sort out sequence development editor suffix
      if [[ ${sde} -eq 1 ]]; then
        fmap=$(echo ${bold} | sed "s,bold,epi,g")
      else
        fmap=$(dirname ${bold})/$(basename ${bold} _bold.nii.gz)_epi.nii.gz
      fi

      # rename 'bold', 'epi', and 'phase'
      for ext in "_bold.nii.gz" "_epi.nii.gz" "_bold_ph.nii.gz"; do

        if [[ ${ext} == "_bold.nii.gz" ]]; then
          orig=${func}
          image="func"
        elif [[ ${ext} == "_epi.nii.gz" ]]; then
          orig=${fmap}
          image="fmap"
        elif [[ ${ext} == "_bold_ph.nii.gz" ]]; then
          orig=${phase}
          image="phase"
        fi

        # compile filename
        ff=$(construct_bids_filename "${bold}" "${bids_dir}" "${image}" "${base}" "${run}" "${ext}" "${count}")
        if [[ ! -f "${ff}" || ${OW} -eq 1 ]]; then

          txt=""
          if [[ ${reorient} -eq 1 ]]; then
            txt=" and reorienting to LPI"
          fi

          if [[ -f "${orig}" ]]; then

            # only create directory if orig file exists
            if [[ ! -d ${ff} ]]; then
              mkdir -p $(dirname ${ff})
            fi

            echo "  Renaming ${image}-file to $(basename ${ff})${txt}"
            cp "${orig}" "${ff}"

            # cut volumes
            maybe_trim_volumes "${ff}" "${image}" "${cut_vols}" "${trim_fmap}"

            # also reorient to LPI because dcm2niix does AIL, parrec2nii does RPI woohoo.. Fun.
            maybe_reorient "${ff}" "${reorient}"

            # sort out json-files
            handle_json_metadata "${orig}" "${ff}" "${image}" "${set_tr}" "${skip_tr}" "${pe_dir}" "${idx}"
          fi
        else
          echo "  $(basename ${ff}) exists"
        fi
      done

      ((idx++))
    done

    # look for deviating filenaming (e,g., dir-AP)
    scrape_and_link_fieldmaps \
      "${tmp_dir}" \
      "${bids_dir}" \
      "${set_tr}" \
      "${skip_tr}" \
      "${cut_vols}" \
      "${trim_fmap}" \
      "${reorient}"

    # final fix
    fix_final_intendedfor "${bids_dir}"

  fi

  #---------------------------------------------------------------------------------------------------------
  # check for event files
  if [[ -z ${runs} ]]; then
    tsv_files=($(find -L "${input_dir}" -type f \( -name "*.tsv*" \) | sort 2>/dev/null))
  else
    if [[ ${#n_runs[@]} -gt 1 ]]; then
      tsv_files=()
      for r in ${n_runs[@]}; do
        run_f=$(find -L "${input_dir}" -type f \( -name "*run-${r}*" -and -name "*.tsv" \) 2>/dev/null)
        tsv_files+=(${run_f})
      done
    else
      tsv_files=$(find -L "${input_dir}" -type f \( -name "*run-${n_runs}*" -and -name "*.tsv" \) 2>/dev/null)
    fi
  fi

  if [[ ! -z ${tsv_files} ]]; then
    
    if [[ ! -d ${bids_dir}/func ]]; then
      mkdir -p ${bids_dir}/func
    fi
    echo " Found ${#tsv_files[@]} event file(s)"    

    count=0
    for file in ${tsv_files[@]}; do
      
      # add counter in case file does not contain run-X id
      ((count++))

      # fetch task
      task=`get_id ${file} task`

      # fetch run
      run=`get_id ${file} run`
      if [[ -z ${run} ]]; then
        run=${count}
      fi              

      acq=`get_id ${file} acq`
      if [[ ! -z ${acq} ]]; then
        add_acq="_acq-${acq}"
      else
        add_acq=""
      fi

      bids_tsv=${bids_dir}/func/${base}_task-${task}_run-${run}${add_acq}_events.tsv
      if [[ ! -f ${bids_tsv} || ${OW} -eq 1 ]]; then
        echo -e "  renaming TSV-file to ${BOLD_GREEN}$(basename ${bids_tsv})${RESET}"
        cp ${file} ${bids_tsv}
      fi
    done
  fi

  #---------------------------------------------------------------------------------------------------------
  # check for eyetracker files
  if [[ -z ${runs} ]]; then
    edf_files=($(find -L "${input_dir}" -type f \( -name "*.edf*" \) 2>/dev/null))
  else
    if [[ ${#n_runs[@]} -gt 1 ]]; then
      edf_files=()
      for r in ${n_runs[@]}; do
        run_f=$(find -L "${input_dir}" -type f \( -name "*run-${r}*" -and -name "*.edf" \) 2>/dev/null)
        edf_files+=(${run_f})
      done
    else
      edf_files=$(find -L "${input_dir}" -type f \( -name "*.edf*" \) 2>/dev/null)
    fi
  fi


  if [[ ! -z ${edf_files} ]]; then

    if [[ ! -d ${bids_dir}/func ]]; then
      mkdir -p ${bids_dir}/func
    fi

    echo " Found ${#edf_files[@]} eyetracker file(s)"    

    count=0
    for file in ${edf_files[@]}; do
      
      # add counter in case file does not contain run-X id
      ((count++))

      # fetch task
      task=`get_id ${file} task`
      if [[ ${task} == "prf" ]]; then
        task="pRF"
      fi

      # fetch run
      run=`get_id ${file} run`
      if [[ ${run} -eq 0 ]]; then
        run=${count}
      fi

      bids_edf=${bids_dir}/func/${base}_task-${task}_run-${run}_eye.edf
      if [[ ! -f ${bids_edf} || ${OW} -eq 1 ]]; then
        echo -e "  renaming EDF-file to ${BOLD_GREEN}$(basename ${bids_edf})${RESET}"
        cp ${file} ${bids_edf}
      fi              
    done
  fi          
fi

#---------------------------------------------------------------------------------------------------------
# check for physio files
phys=($(find -L "${input_dir}" -type f \( -name "*SCANPHYS*" -and -name "*bold*" -and -name "*.log" \) | sort 2>/dev/null))
if [[ ! -z ${phys} ]]; then

  echo " Found physio file(s)"
  if [[ ! -d ${bids_dir}/physio ]]; then
    mkdir -p ${bids_dir}/physio
  fi            

  count=0
  for file in ${phys[@]}; do
    
    # add counter in case file does not contain run-X id
    ((count++))

    # fetch task
    task=`get_id ${file} task`
    add_task=""
    if [ ! -z ${task} ]; then
      if [[ ${task} == "prf" ]]; then
        task="pRF"
      fi
      add_task="_task-${task}"
    fi

    # fetch run
    add_run=""
    run=`get_id ${file} run`
    if [[ ! -z ${run} ]]; then
      if [[ ${run} -eq 0 ]]; then
        run=${count}
      fi           
      add_run="_run-${run}"
    fi

    # check if we got acquisition; if we also got desc, add it to acq, as fMRIprep doesn't like the desc- field
    acq=`get_id ${file} acq`
    if [[ ! -z ${acq} ]]; then
      add_acq="_acq-${acq}"
      if [[ ! -z ${desc} ]]; then
        add_acq+="${desc}"
      fi
    else
      add_acq=""
      if [[ ! -z ${desc} ]]; then
        add_acq="_acq-${desc}"
      fi
    fi    

    # define base
    phys_base=${base}${add_task}${add_run}${add_acq}

    # look for accompanying func/par file
    func_phys=$(find ${bids_dir}/func -type f -iname "${phys_base}*" -and -name "*.nii.gz")

    if [[ ! -z ${func_phys} ]]; then
      phys_base=$(basename ${func_phys} _bold.nii.gz)_physio.log

      bids_phys=${bids_dir}/physio/${phys_base}
      if [[ ! -f ${bids_phys} ]]; then
        echo -e "  renaming physio-file to ${BOLD_GREEN}$(basename ${bids_phys})${RESET}"
        cp ${file} ${bids_phys}
      fi

      # check if scanphyslog2bids is installed | will throw error if it doesn't
      fn_exists scanphyslog2bids 1

      # convert to readable format
      out_=$(dirname ${bids_phys})/$(basename ${bids_phys} .log)
      call_spmphysio \
        -f ${func_phys} \
        --no-plots \
        --use_bids \
        ${bids_phys} \
        ${out_}

      # add func file to json
      if [[ $? -eq 0 ]]; then
        if [[ -f ${out_}.json ]]; then
          call_json ${out_}.json FuncFile ${func_phys}
        fi
      fi
    fi
  done
fi
echo "Done"

if [[ ${warning} -eq 1 ]]; then
  echo
  print_line -
  echo "WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING"
  echo ""
  if [[ ${pe_warning} -eq 1 ]]; then
    echo "I assumed the PhaseEncoding direction in the FMAP/FUNC-folder; please make sure this is correct!"
  fi

  if [[ ${mb_warning} -eq 1 ]]; then
    echo "I might have assumed information about the acceleration factor to get the slice timings.."
  fi

  echo "Please check that this is correct!"
  print_line -
fi
