#!/usr/bin/env bash

# ---------------------------------------------------------------------------------------------------
# Get full path without the requirement that it exists
generate_submission_command() {
    local queue="$1"
    local n_cpus="$2"
    local job_name="$3"
    local workdir="$4"   # This can be either a directory or a file

    local system="unknown"
    local command=""
    local log_path=""

    # Check scheduler type
    system=$(detect_scheduler) || return 1  # Detect scheduler and exit on error

    # Determine if workdir is a file or a directory
    if [[ -d "$workdir" ]]; then
      if [[ "$system" == "slurm" ]]; then
        # SLURM auto appends filename if only directory is given
        log_path="${workdir}/%x_%j.out"
      else
        # SoGE requires explicit filename
        log_path="${workdir}/${job_name}.log"
      fi
    else
      # Assume full file path is given
      log_path="$workdir"
    fi

    # Build submission command
    if [[ "$system" == "soge" ]]; then
        command="qsub -q ${queue} -pe smp ${n_cpus} -N ${job_name} -o ${log_path} -j Y -V"
    elif [[ "$system" == "slurm" ]]; then
        command="sbatch --partition=${queue} --cpus-per-task=${n_cpus} --job-name=${job_name} --output=${log_path} --export=ALL"
    fi

    # Output the result
    echo "$command"
}

print_line() {
  local char="${1:-=}"  # default to '='
  local width="${TERMINAL_WIDTH:-99}"

  printf "%*s\n" "$width" "" | tr ' ' "$char"
}

load_colors() {
  # Text reset
  RESET="\033[0m"

  # Bold colors
  BOLD_BLACK="\033[1;30m"
  BOLD_RED="\033[1;31m"
  BOLD_GREEN="\033[1;32m"
  BOLD_YELLOW="\033[1;33m"
  BOLD_BLUE="\033[1;34m"
  BOLD_MAGENTA="\033[1;35m"
  BOLD_CYAN="\033[1;36m"
  BOLD_WHITE="\033[1;37m"

  # Usage hint
  export RESET
  export BOLD_BLACK BOLD_RED BOLD_GREEN BOLD_YELLOW
  export BOLD_BLUE BOLD_MAGENTA BOLD_CYAN BOLD_WHITE
}

# load the colors
load_colors

# print executable in color
print_cmd() {
  local cmd="$*"

  # Extract the first word (executable)
  local executable="${cmd%% *}"
  local rest="${cmd#${executable}}"

  # Print with just the executable in color
  echo -e "${BOLD_BLUE}${executable}${RESET}${rest}"
}

activate_conda() {
  local env_name="$1"
  if [[ -z "$env_name" ]]; then
    echo "Usage: activate_conda <env_name>"
    return 1
  fi

  echo "Deactivating all existing Conda environments..."

  local attempt=0
  local max_attempts=10

  # Deactivate until fully clean
  while true; do
    local active_env
    active_env=$(conda info | grep "active environment" | awk -F':' '{print $2}' | xargs)

    if [[ "$active_env" == "None" ]]; then
      break
    fi

    conda deactivate &>/dev/null
    ((attempt++))

    if [[ $attempt -ge $max_attempts ]]; then
      echo "⚠️  Warning: could not fully clear Conda env stack after $attempt deactivations"
      break
    fi
  done

  echo "Activating Conda environment: ${env_name}"
  conda activate "$env_name" &>/dev/null

  # Optional: confirm
  local current_python=$(which python)
  echo "Environment '$env_name' activated"
  echo "Python: $current_python"
}

# ---------------------------------------------------------------------------------------------------
# subject header
print_subject_header() {

  # load the colors
  load_colors
  local subject="$1"
  local total_width="${TERMINAL_WIDTH:-99}"

  # Colored subject ID
  local base_msg="Processing ${BOLD_CYAN}${subject}${RESET}"
  local plain_msg="Processing ${subject}"  # uncolored for length calculation
  local msg="*** ${base_msg} ***"
  local plain_full="*** ${plain_msg} ***"
  local msg_len=${#plain_full}

  # Handle case where message is longer than total width
  if [[ $msg_len -ge $total_width ]]; then
    echo "$msg"
    return
  fi

  # Calculate padding on each side
  local padding_total=$((total_width - msg_len))
  local padding_left=$((padding_total / 2))
  local padding_right=$((padding_total - padding_left))

  local line=$(printf "%*s" "$total_width" "" | tr ' ' '=')
  local stars_left=$(printf "%*s" "$padding_left" "" | tr ' ' '*')
  local stars_right=$(printf "%*s" "$padding_right" "" | tr ' ' '*')

  echo
  echo -e "${stars_left}${msg}${stars_right}"
}

print_output_exists() {
  subject="${1}"
  output="${2}"
  extra="${3}"

  if [[ -f "${output}" ]]; then
    txt=$(basename "${output}")
  else
    txt="${output}"
  fi

  echo -e "${BOLD_CYAN}${subject}${RESET}: output already exists [${BOLD_GREEN}${txt}${RESET}]. ${extra}"
}

print_directory_not_exist() {
  dir="${1}"
  extra="${2}"
  echo -e "${BOLD_CYAN}${subject}${RESET}: could not find input directory [${dir}]. ${extra}"
}


# ---------------------------------------------------------------------------------------------------
# Start timing a process
function start_timer() {
    echo
    print_line =
    printf "${1}\n"
    start=$(date +%s)
    start_date=$(date)
    printf "Started at ${start_date}\n"
    print_line =
}

# ---------------------------------------------------------------------------------------------------
# End timing a process
function end_timer() {
    echo
    print_line -
    end=$(date +%s)
    end_date=$(date)
    printf "Done at ${end_date}\n"

    local deltatime=$((end - start))
    local hours=$((deltatime / 3600))
    local minutes=$(((deltatime / 60) % 60))
    local seconds=$((deltatime % 60))

    printf "Time spent: %d:%02d:%02d\n" ${hours} ${minutes} ${seconds}
    print_line -
}

function conda2jupyter {
  conda activate ${1}
  python -m ipykernel install --user --name=${1}
  conda deactivate
}

function reverse_array {
  array=("${@}")
  min=0
  max=$(( ${#array[@]} -1 ))

  while [[ min -lt max ]]
  do
      # Swap current first and last elements
      x="${array[$min]}"
      array[$min]="${array[$max]}"
      array[$max]="$x"

      # Move closer
      (( min++, max-- ))
  done

  IFS=" "
  read -ra arr <<< "$array"
}

function recache_mpl_fonts {
  
  cache_file=`find ~/.cache/matplotlib -type f -name "*fontlist*"`
  if [[ ! -z ${cache_file} ]]; then
    rm -r ${cache_file} 2>/dev/null
  fi

  python_code="""import matplotlib.font_manager; matplotlib.font_manager._load_fontmanager(try_read_cache=False);"""
  python3 -c "${python_code}"
}

function find_hierarchical_anatomy {

  #---------------------------------------------------------------------------------------------------------
  # Create help text
  function Usage {
      cat <<USAGE

---------------------------------------------------------------------------------------------------
find_hierarchical_anatomy

Find the correct folder with anatomies depending on the processing steps that you've conduc-
ted. The following codes represent certain stages of anatomical preprocessing:
  1 = DIR_DATA_HOME; no preprocessing has done, take the T1w from the scanner
  2 = DIR_DATA_DERIV/pymp2rage; combination with pym2rage; if not present, default to DIR_DATA_HOME
  3 = DIR_DATA_DERIV/denoising; denoising with CAT12 (sanlm); if not present, look for pymp2rage, 
      then DIR_DATA_HOME
  4 = DIR_DATA_DERIV/cat12; segmentation with CAT12 (sanlm); if not present, look for denoised, py-
      mp2rage, then DIR_DATA_HOME      
  5 = DIR_DATA_DERIV/masked_${DATA,,}; anatomicals void of garbage such as sinus. If not present, 
      look for "denoised" > "pymp2rage" > "DIR_DATA_HOME"
  6 = Same as 5, but instead of looking for intermediate folders (denoised/pymp2rage), directly go 
      to DIR_DATA_HOME

Args:
 <code> 1-6

Usage:
 find_hierarchical_anatomy 1
 find_hierarchical_anatomy 5

---------------------------------------------------------------------------------------------------

USAGE
}
  if [[ $# -eq 0 ]]; then
    Usage >&2
  else
    stage=${1}

    INPUT_DIR=""
    if [[ ${stage} -eq 1 ]]; then
      INPUT_DIR=${DIR_DATA_HOME}
    elif [[ ${stage} -eq 2 ]]; then
      if [[ -d ${DIR_DATA_DERIV}/pymp2rage ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/pymp2rage
      else
        INPUT_DIR=${DIR_DATA_HOME}
      fi
    elif [[ ${stage} -eq 3 ]]; then
      if [[ -d ${DIR_DATA_DERIV}/denoised ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/denoised
      elif [[ -d ${DIR_DATA_DERIV}/pymp2rage ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/pymp2rage
      else
        INPUT_DIR=${DIR_DATA_HOME}
      fi
    elif [[ ${stage} -eq 4 ]]; then
      if [[ -d ${DIR_DATA_DERIV}/cat12 ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/cat12    
      elif [[ -d ${DIR_DATA_DERIV}/denoised ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/denoised
      elif [[ -d ${DIR_DATA_DERIV}/pymp2rage ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/pymp2rage
      else
        INPUT_DIR=${DIR_DATA_HOME}
      fi    
    elif [[ ${stage} -eq 5 ]]; then
      if [[ -d ${DIR_DATA_DERIV}/masked_${DATA,,} ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/masked_${DATA,,}
      elif [[ -d ${DIR_DATA_DERIV}/cat12 ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/cat12    
      elif [[ -d ${DIR_DATA_DERIV}/denoised ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/denoised
      elif [[ -d ${DIR_DATA_DERIV}/pymp2rage ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/pymp2rage
      else
        INPUT_DIR=${DIR_DATA_HOME}
      fi        
    elif [[ ${stage} -eq 6 ]]; then
      if [[ -d ${DIR_DATA_DERIV}/masked_${DATA,,} ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/masked_${DATA,,}
      else
        INPUT_DIR=${DIR_DATA_HOME}
      fi           
    else
      echo "ERROR in find_hierarchical_anatomy: invalid stage code \"${stage}\""
    fi

    echo $INPUT_DIR
  fi
}

function search_character_substring {
  input=${1}
  searchstring=${2}
  rest=${input#*$searchstring}
  starts_at=`echo $(( ${#input} - ${#rest} - ${#searchstring} ))`
  echo $starts_at
}

function read_json {

  #---------------------------------------------------------------------------------------------------------
  # Create help text
  function Usage {
      cat <<USAGE

---------------------------------------------------------------------------------------------------
read_json

Read parameters from a json-file. 

Args:
 <json file>  PAR/par file to read
 <read key>   key to read from the json file

Usage:
 read_json some_file.json "RepetitionTime"

---------------------------------------------------------------------------------------------------

USAGE
}

  if [[ $# -lt 2 ]] ; then
    Usage >&2
  else

    json_file=${1}
    read_key=${2}

    if [[ -z ${read_key} ]]; then
      echo "Please specify a key (e.g., \"RepetitionTime\") to read"
    else
      # reads x lines, cuts the :, removes white spaces, and removes carriage return
      json_key=`cat ${json_file} | grep ${read_key} | cut -d':' -f2`
      if [ ! -z ${json_key} ]; then
        if [[ ${json_key} == *","* ]]; then
          json_key=`echo ${json_key} | cut -d"," -f1`
        fi
        json_key=`echo ${json_key} |  xargs | sed 's/\r$//'`
        echo ${json_key}
      else
        echo ""
      fi
    fi
  fi

}

function read_par {

  #---------------------------------------------------------------------------------------------------------
  # Create help text
  function Usage {
      cat <<USAGE

---------------------------------------------------------------------------------------------------
read_par

Read parameters from a PAR-file. 

Args:
 -r <lines>   number of lines to read from the par file (default is 50)
 <par file>   PAR/par file to read
 <read key>   key to read from the par file

Usage:
 read_par some_file.par "EPI factor"

---------------------------------------------------------------------------------------------------

USAGE
}

  if [[ $# -lt 1 ]] ; then
    Usage >&2
  else
    # Check for subject & session flags
    read_lines=50
    par_file=${1}
    if [[ $# -eq 3 ]]; then
      read_lines=${1}
      par_file=${2}
      read_key=${3}
    elif [[ $# -eq 2 ]]; then
      par_file=${1}
      read_key=${2}
    fi

    if [[ -z ${read_key} ]]; then
      echo "Please specify a key (e.g., \"number of echoes\") to read"
    else
      # reads x lines, cuts the :, removes white spaces, and removes carriage return
      par_key=`head -${read_lines} ${par_file} | grep "${read_key}" | cut -d":" -f2 | xargs | sed 's/\r$//'`
      echo ${par_key}
    fi

  fi

}

function phase_encoding_from_dcm {
    dcm_file="$1"

    if [[ ! -f "$dcm_file" ]]; then
        echo "Error: File does not exist - $dcm_file"
        return 1
    fi

    phase_encoding=$(python3 - <<END
import pydicom

dcm = pydicom.dcmread("$dcm_file")
phase_encoding = getattr(dcm, "InPlanePhaseEncodingDirection", "UNKNOWN")
print(phase_encoding)
END
)
    echo "$phase_encoding"
}

function read_dcm {

  #---------------------------------------------------------------------------------------------------------
  # Create help text
  function Usage {
      cat <<USAGE

---------------------------------------------------------------------------------------------------
read_dcm

Read parameters from a dcm-file. 

Args:
 <dm file>    dcm file to read
 <read key>   key to read from the dcm file

Usage:
 read_dcm some_file.dcm "PatientID"

---------------------------------------------------------------------------------------------------

USAGE
}

  if [[ $# -lt 1 ]] ; then
    Usage >&2
  else

    PYTHON_CODE=$(cat <<END
from pydicom import dcmread

dcm = dcmread("${1}")

if "$2" == "NumberOfImagesInMosaic":
  res = dcm.get((0x0019, 0x100a), None)
  res = res.value if res is not None else ""
elif "${2}" == "polarity":
  res = dcm.get((0x0051, 0x1013), None)
  res = res.value if res is not None else ""
elif "${2}" == "PhaseEncodingDirection":
  res = dcm.get((0x0018, 0x1312), None)
  res = res.value if res is not None else ""  
else:
  res = getattr(dcm, "${2}", None)

print(res)
END
)
    if [[ ${2} == "RepetitionTime" ]]; then
      res=`tr_from_dcm ${1}`
    elif [[ ${2} == "PhaseEncodingDirection" ]]; then
      res=`phase_encoding_from_dcm ${1}`
    else
      res=("$(python -c "${PYTHON_CODE}")")
    fi

    echo $res

  fi

}

collect_subject_name() {
  local sub="$1"
  local subID="$2"
  local prefix="$3"

  if [[ -n ${sub} ]]; then
    echo "${prefix}${subID}"
  else
    echo "$(basename "${subID}")"
  fi
}

get_subject_id() {
  local sub="$1"
  local subID="$2"
  local prefix="$3"

  if [[ -n ${sub} ]]; then
    echo "${subID}"
  else
    echo "$(basename "${subID}")"
  fi
}

collect_session_info() {
  local ses="$1"
  local sub_name="$2"

  if [[ -n ${ses} ]]; then
    local nr
    nr=$(echo "${ses}" | sed -e 's/^[[:space:]]*//')
    echo "${sub_name}/ses-${nr} ${sub_name}_ses-${nr}"
  else
    echo "${sub_name} ${sub_name}"
  fi
}

function pe_from_dcm {

  dcm_file=${1}
  axis=`read_dcm ${dcm_file} PhaseEncodingDirection`
  csa_dir=`read_dcm ${dcm_file} polarity`

  # phase encoding direction; check variable in setup file
  if [ ! -z ${PE_DIR_BOLD} ]; then
    PE=${PE_DIR_BOLD}
    bids_pe=`fprep_pe ${PE}`
  else
    # Infer BIDS PhaseEncodingDirection
    if [[ "$axis" == "COL" ]]; then
        if [[ "$csa_dir" == *"L"* ]]; then
            bids_pe="j"
        elif [[ "$csa_dir" == *"R"* ]]; then
            bids_pe="j-"
        else
            echo "Error: Unexpected CSA Direction for COL: $csa_dir" >&2
            exit 1
        fi
    elif [[ "$axis" == "ROW" ]]; then
        if [[ "$csa_dir" == *"P"* ]]; then
            bids_pe="i"
        elif [[ "$csa_dir" == *"A"* ]]; then
            bids_pe="i-"
        else
            echo "Error: Unexpected CSA Direction for ROW: $csa_dir" >&2
            exit 1
        fi
    else
        echo "Error: Could not read InPlanePhaseEncodingDirection." >&2
        exit 1
    fi

  fi

  echo "${bids_pe}"

}

function tr_from_par {
  #---------------------------------------------------------------------------------------------------------
  # Create help text
  function Usage {
      cat <<USAGE

---------------------------------------------------------------------------------------------------
tr_from_par

Extract the TR from a PAR-file. This is done by reading the 'dtime' column, getting the 
unique values, then taking the mean (if 'average') over np.diff(), or its first element
('first') 

Args:
  <par file>    PAR/par file to read
  <protocol>    which TR to take: either the average over all TRs ('average'), or the first ('first')

Returns:
  RepetitionTime

Usage:
 tr_from_par some_file.par average [default]
 tr_from_par some_file.par first

---------------------------------------------------------------------------------------------------

USAGE
}

  if [[ $# -lt 1 ]] ; then
    Usage >&2
  else

    par=${1}
    use_case=${2}

    if [[ -z ${use_case} ]]; then
      use_case="average"
    fi

    # fetch where parameters begin
    str="=== IMAGE INFORMATION ="
    line_startpar=`grep -n -m 1 "${str}" ${par} | sed  's/\([0-9]*\).*/\1/'`

    # get TR column
    tr_column=(`sed -n "$((${line_startpar}+2)),$ p" ${par} | awk '{ print $32 }' | sed 's/\r$//'`)

    tr_file=$(dirname ${par})/tr.txt
    if [[ -f ${tr_file} ]]; then
      rm -r ${tr_file}
    fi
    
    # echo list of TRs to tmp file to use np.diff
    echo ${tr_column[@]} >> ${tr_file}

    # define python code
    PYTHON_CODE="""
try:
  import numpy as np;
  trs = np.unique(np.loadtxt('${tr_file}'));
  isi = np.diff(trs);
  if '${use_case}' == 'average': 
    tr = isi.mean();
  else:
    tr = isi[0];
  print(tr);
except:
  print(999);
"""

    # run python code
    tr="$(python -c "$PYTHON_CODE")"

    # remove tmp file
    if [[ -f ${tr_file} ]]; then
      rm -r ${tr_file}
    fi

    echo ${tr}
  fi  
}

function add_par_file {

  #---------------------------------------------------------------------------------------------------------
  # Create help text
  function Usage {
      cat <<USAGE

---------------------------------------------------------------------------------------------------
add_par_file

Add the PAR-file to the jsons of newly converted files with dcm2niix. This ensures we retain the 
link with the PAR-file so we can extract information from it

Args:
  pathInput   input directory for dcm2niix; where the par-files live
  pathOutput  output directory for dcm2niix; where the nifti's are stored. If empty, we'll default
              to pathInput/nifti, just like call_dcm2niix

Usage:
 add_par_file input_folder output_folder

---------------------------------------------------------------------------------------------------

USAGE
}

  do_stuff=1
  if [[ $# -lt 1 ]] ; then
    Usage >&2
    do_stuff=0
  elif [[ $# -eq 1 ]]; then
    pathInput=${1}
    pathOutput=${pathInput}/nifti
  elif [[ $# -eq 2 ]]; then
    pathInput=${1}
    pathOutput=${2}  
  fi

  if [[ ${do_stuff} -eq 1 ]]; then
    for ii in ${pathOutput}/*.nii.gz; do
      if [[ $(basename ${ii}) == *"_bold"* || $(basename ${ii}) == *"_epi"* ]]; then
        # cross reference with par files in pathInput
        for par in ${pathInput}/*; do

          # if file > philips
          if [ -f ${par} ]; then
            ext=`fetch_extension ${par}`
            ext_lower=$(echo "$ext" | tr '[:upper:]' '[:lower:]')
            if [[ ${ext_lower} == *"par"* ]]; then
              pat=`read_par ${par} "Patient name"`
              prot=`read_par ${par} "Protocol name"`

              # assuming dcm2niix command above did not change!
              nifti_from_par=${pathOutput}/${pat}_${prot}
              if [[ ${nifti_from_par}.nii.gz -ef ${ii} ]]; then
                call_json ${nifti_from_par}.json ParFile ${par}
              fi
            fi
          elif [ -d ${par} ]; then

            # deal with siemens DCM folders
            if [[ "$(basename ${par})" =~ ^[0-9] ]]; then

              # reconstruct filename from dcm file for each directory
              dcm_tmp=`find ${par} -type f -name "*.dcm" | head -n 1`
              pat=`read_dcm ${dcm_tmp} "PatientName"`
              prot=`read_dcm ${dcm_tmp} "ProtocolName"`

              # assuming dcm2niix command above did not change!
              nifti_from_dcm=${pathOutput}/${pat}_${prot}
              if [[ ${nifti_from_dcm}.nii.gz -ef ${ii} ]]; then
                call_json ${nifti_from_dcm}.json ParFile ${dcm_tmp}
              fi
            fi
          fi
        done
      fi
    done
  fi

}

function tr_from_dcm {
    local help_text="
---------------------------------------------------------------------------------------------------
tr_from_dcm - Extract TR (Repetition Time) from a Siemens DICOM.

Usage:
    tr_from_dcm <dicom_file>

This function extracts the TR using these strategies:

1. Parse TR directly from the filename if present (TR2.9, TR=2.9, TR_2p9, _TR2p9_).
   This is the most reliable for modern Siemens 3D EPI.

2. For 3D acquisitions, trust RepetitionTime (0018,0080) from DICOM directly.

3. For 2D Mosaic acquisitions, calculate TR = NumSlices × SliceMeasurementDuration.
   This works for Siemens 2D-EPI (especially in fMRI).

4. For 2D multi-band sequences, apply multi-band correction (TR / MultiBandFactor).

5. Final TR is reported in **seconds**.
---------------------------------------------------------------------------------------------------
"

    if [[ $# -lt 1 ]]; then
        echo "$help_text"
        return 1
    fi

    dcm_file="$1"
    if [[ ! -f "$dcm_file" ]]; then
      echo "Error: File does not exist - $dcm_file"
      return 1
    fi

    # Extract TR hint from filename (supports multiple patterns)
    filename_tr=""
    if [[ "$dcm_file" =~ [Tt][Rr][=_]?([0-9]+\.[0-9]+) ]]; then
        filename_tr="${BASH_REMATCH[1]}"
    elif [[ "$dcm_file" =~ _[Tt][Rr]([0-9]+p[0-9]+)_ ]]; then
        filename_tr=$(echo "${BASH_REMATCH[1]}" | tr 'p' '.')
    fi

    read -r acquisition_type repetition_time image_type num_slices slice_duration mb_factor <<EOF
$(python3 - <<END
import pydicom
import re

dcm = pydicom.dcmread("$dcm_file")

acquisition_type = getattr(dcm, "MRAcquisitionType", "Unknown").lower()
repetition_time = float(dcm.RepetitionTime) / 1000  # ms -> s
image_type = ",".join(dcm.ImageType)

num_slices = dcm.get((0x0019, 0x100a), None)
slice_duration = dcm.get((0x0019, 0x100b), None)

num_slices = num_slices.value if num_slices else ""
slice_duration = float(slice_duration.value) / 1000 if slice_duration else ""  # ms -> s

mb_factor = ""
csa_header = dcm.get((0x0029, 0x1010), None)
if csa_header:
    try:
        csa_str = csa_header.value.decode(errors="ignore")
        match = re.search(r"sSliceArray.lMultiBandFactor\s*=\s*(\d+)", csa_str)
        if match:
            mb_factor = match.group(1)
    except Exception:
        pass

print(acquisition_type, repetition_time, image_type, num_slices, slice_duration, mb_factor)
END
)
EOF

    volume_tr="$repetition_time"  # Default TR from DICOM header

    if [[ "$acquisition_type" == "2d" && "$image_type" == *"MOSAIC"* ]]; then
      if [[ -n "$num_slices" && -n "$slice_duration" ]]; then
        volume_tr=$(awk -v ns="$num_slices" -v sd="$slice_duration" 'BEGIN {print ns * sd}')
      fi

      if [[ -n "$mb_factor" && "$mb_factor" -gt 1 ]]; then
        volume_tr=$(awk -v tr="$volume_tr" -v mb="$mb_factor" 'BEGIN {print tr / mb}')
      fi
    fi

    # Filename TR overrides if detected
    if [[ -n "$filename_tr" ]]; then
      delta=$(awk -v tr1="$volume_tr" -v tr2="$filename_tr" 'BEGIN {print (tr1 > tr2) ? tr1 - tr2 : tr2 - tr1}')
      volume_tr="$filename_tr"
    fi

    echo $volume_tr
}



function pars_for_json {

  #---------------------------------------------------------------------------------------------------------
  # Create help text
  function Usage {
      cat <<USAGE

---------------------------------------------------------------------------------------------------
pars_for_json

Calculate the following parameters from a PAR-file:
  - Water fat shift (WFS_hz)      | water fat shift*water fat ppm*gyromagnetic ratio
  - Total readout time (TRT)      | water fat shift/WFS_hz
  - Effective echo spacing (EES)  | TRT/EPI factor+1
  - Phase encoding direction      | in fmriprep convention (e.g., AP='j-')
  - MagneticFieldStrength         | default 7.0, can be set with env variable FIELD_STRENGTH
  - EPIFactor                     | -
  - ProtocolName                  | -
  - MultibandAccelerationFactor   | if MB_FACTOR is set in the environment (if scan mode != 3D)
  - Scan mode                     | MS/3D

Args:
  --merge       don't overwrite existing keys
  <par file>    PAR/par file to read
  <json file>   output file; if not specified, the output is printed to the terminal. You can
                choose to redirect this output to another file using 'pars_for_json ... &> some_
                file.txt'

Returns:
  array in the following order: WFS,WFS_hz,TRT,EES,PE

Usage:
 pars_for_json some_file.par

---------------------------------------------------------------------------------------------------

USAGE
}

  if [[ $# -lt 1 ]] ; then
    Usage >&2
  else

    MERGE=""
    par_file=${1}
    if [[ $# -eq 1 ]]; then
      par_file=${1}
      json_file=""
    elif [[ $# -eq 2 ]]; then
      par_file=${1}
      json_file=${2}
    elif [[ $# -eq 3 ]]; then
      par_file=${2}
      json_file=${3}
      MERGE="--merge"
    fi

    # fielstrength
    if [[ -z ${FIELD_STRENGTH} ]]; then
      FIELD_STRENGTH=7.0
    fi
    
    # gyromagnetic ratio
    gyro=42.576

    # water-fat part per million
    wf_ppm=3.35

    # EPI factor
    epi_f=`read_par ${par_file} "EPI factor"`

    # water fat shift
    WFS=`read_par ${par_file} "Water Fat shift"`

    # WFS (freq)
    WFS_hz=`echo "${FIELD_STRENGTH} * ${wf_ppm} * ${gyro}" |bc -l`

    # total read out time
    TRT=`echo "${WFS} / ${WFS_hz}" | bc -l`

    # effective echo spacing (EPI factor +1)
    EES=`echo "${TRT}/(${epi_f}+1)" | bc -l`

    # phase encoding direction; check variable in setup file
    if [ -z ${PE_DIR_BOLD} ]; then
      PE=`read_par ${par_file} "Preparation direction"`
    else
      PE=${PE_DIR_BOLD}
    fi

    ADD_PE=`fprep_pe ${PE}`

    # protocol name
    PROT=`read_par ${par_file} "Protocol name"`

    # EPI factor
    EPI_FACTOR=`read_par ${par_file} "EPI factor"`

    # protocol name
    PROT_NAME=`read_par ${par_file} "Protocol name"`

    # acquisition scheme
    AQ=`read_par ${par_file} "Scan mode"`

    # flip PE if protocol name is BOLD but json file EPI
    txt=""
    if [[ ${PROT} == *"_bold"* ]]; then
      if [[ -f ${json_file} ]]; then
        if [[ $(basename ${json_file}) == *"epi.json"* ]]; then
          ADD_PE=`fprep_pe ${PE} 1`
          txt="flipped for epi_json"
        else
          ADD_PE=`fprep_pe ${PE} 0`
          txt="not flipped"
        fi
      else
        ADD_PE=`fprep_pe ${PE} 0`
        txt="not flipped"
      fi
    elif [[ ${PROT} == *"_epi"* ]]; then
      ADD_PE=`fprep_pe ${PE} 1`
      txt="flipped for epi_json"
    fi

    if [[ ! -z ${json_file} ]]; then
      call_json ${merge} ${json_file} TotalReadoutTime,PhaseEncodingDirection,EffectiveEchoSpacing,ProtocolName,MagneticFieldStrength,WaterFatShift,EPIFactor,ProtocolName,AcquisitionTechnique ${TRT},${ADD_PE},${EES},${PROT},${FIELD_STRENGTH},${WFS},${EPI_FACTOR},${PROT_NAME},${AQ}

      if [[ ! -z ${MB_FACTOR} ]]; then
        if [[ ${AQ} != "3D" ]]; then
          call_json ${json_file} MultiBandAccelerationFactor ${MB_FACTOR}
        fi
      fi
    else
      echo "Field:  ${FIELD_STRENGTH}T"
      echo "WFS:    ${WFS}"
      echo "WFS_hz: ${WFS_hz}"
      echo "TRT:    ${TRT}"
      echo "EES:    ${EES}"
      echo "EPI fc: ${EPI_FACTOR}"
      echo "Prot:   ${PROT_NAME}"
      echo "Mode:   ${AQ}"
      echo "PE:     ${PE} (${ADD_PE}) [${txt}]"
    fi
  fi

}

function fprep_pe {
  PE=${1}
  FLIP=${2}

  # check if we want the flipped version
  if [[ -z ${FLIP} ]]; then
    FLIP=0
  else
    FLIP=${FLIP}
  fi

  # derive code from PE
  if [[ ${PE} == "AP" ]] || [[ ${PE} == "Anterior-Posterior" ]]; then
    if [[ ${FLIP} -eq 0 ]]; then
      ADD_PE="j"
    else
      ADD_PE="j-"
    fi
  elif [[ ${PE} == "PA" ]] || [[ ${PE} == "Posterior-Anterior" ]]; then
    if [[ ${FLIP} -eq 0 ]]; then
      ADD_PE="j-"
    else
      ADD_PE="j"
    fi
  elif [[ ${PE} == "LR" ]] || [[ ${PE} == "Left-Right" ]]; then
    if [[ ${FLIP} -eq 0 ]]; then
      ADD_PE="i"
    else
      ADD_PE="i-"
    fi
  elif [[ ${PE} == "RL" ]] || [[ ${PE} == "Right-Left" ]]; then
    if [[ ${FLIP} -eq 0 ]]; then
      ADD_PE="i-"
    else
      ADD_PE="i"
    fi
  fi

  echo $ADD_PE
}

function add_nordic_msg {

  if [[ $# -ne 2 ]]; then
    echo "Please specify an input folder and the message to add to the json files"
  else
    folder=${1}
    msg=${2}

    if [[ ! -d ${folder} ]]; then
      echo "ERROR: input is not a folder"
    else
      echo "Adding {\"Nordic\": \"${msg}\"} to json-files in \"${folder}\""
      for file in ${folder}/*.json; do
        call_json ${file} "Nordic" "${msg}"
      done
    fi
  fi
}

function fn_exists {

  if [[ $# -eq 0 ]]; then
    echo "ERROR in function: please specify an input"
  else
    func=${1}
    FN=`type -t ${func}`
    if [[ -z ${FN} ]]; then
      echo "Didn't find function \"${func}\""

      if [[ ! -z ${2} ]]; then
        if [[ ${2} -eq 1 ]]; then
          exit 1
        fi
      fi
    fi
  fi
  
}

function check_file {
  input=${1}
  if [ -f ${input} ]; then
    echo "File exists at ${input}"
  elif [ -d ${input} ]; then
    echo "Directory exists at ${input}"
  else
    echo "File/directory \"${input}\" does not exist"
  fi
}

function dykstra_distance {

  if [[ $# -eq 0 ]]; then
    echo
    print_line -
    echo "dykstra_distance"
    echo
    echo "Wrapper for mris_pmake. Calculates the distance between <startVertex> & <endVertex> using Dykstra's"
    echo "algorithm."
    echo
    echo "Usage"
    echo "----------"
    echo "  dykstra_distance <subject> <hemi> <surface> <startVertex> <endVertex> <json file>"
    echo ""
    echo "Parameters"
    echo "----------"
    echo "subject: str"
    echo "  subject ID as per FreeSurfer output"
    echo "hemi: str"
    echo "  hemisphere to process. Must be one of \"lh\" or \"rh\""
    echo "surface: str"
    echo "  surface name to process, e.g., \"fiducial\". Defaults to \"inflated\""
    echo "startVertex: int"
    echo "  vertex to calculate distances TO"
    echo "endVertex: int"
    echo "  vertex to calculate distances FROM"
    echo "json file: str"
    echo "  store the output in a key-value pair between <endVertex> and the output from mris_pmake"
    echo ""
    echo "Example"
    echo "----------"
    echo "  dykstra_distance sub-001 lh fiducial 1053 784"
    echo "  dykstra_distance sub-001 lh fiducial 1053 784 sub-001_desc-distances.json"
    echo ""
    print_line -
    echo
  else
    dist=`mris_pmake --subject ${1} --hemi ${2} --surface ${3} --mpmProg pathFind --mpmArgs vertexStart:${4},vertexEnd:${5} --mpmOverlay distance | sed -n '2p' | cut -d"[" -f2 | cut -d" " -f2`

    # write output to json file
    if [[ ! -z ${6} ]]; then
      call_json ${6} "${5}" "${dist}"
    else
      echo ${dist}
    fi
  fi
}

function flywheel2bids {
  input_dir=${1}
  fname=${2}
  for ii in ${input_dir}/*.json; do
  
    if [[ ${ii} == *"_ph.json"* ]]; then
      suff="_ph"
    else
      suff=""
    fi

    # get SeriesDescription
    SD=`cat ${ii} | grep "SeriesDescription" | cut -d ":" -f2 | cut -d" " -f2 | cut -d"," -f1 | tr -d '"'`
    outbase=${fname}_${SD}${suff}
    mv ${ii} $(dirname $ii)/${outbase}.json
    mv $(dirname $ii)/$(basename ${ii} .json).nii.gz $(dirname $ii)/${outbase}.nii.gz

  done
} 

function permission_codes {
  stat -c "%a %n" *
}

function delete_prefix {
  for i in "$1"*; do mv "$i" "${i#"$1"}"; done
}

function add_prefix {
  for f in *; do mv "$f" "$1$f"; done
}

function get_id {
  func=$(basename $(readlink -f "${1}"))
  tag=${2}
  if [[ ${func} != *"${tag}"* ]]; then
    tag=""
  else
    # need some operations to find the task ID
    part_after_task=${func#*$tag}
    if [[ ! -z ${part_after_task} ]]; then
      # use brute force underscore as delimiter an pray your sequences have been set correctly
      tag=$(echo ${part_after_task} | cut -d'_' -f1 | cut -d"-" -f2)
    else
      # could not derive task; assume its pRF
      tag=""
    fi
  fi

  # get rid of dots by assuming the tag-of-interest precedes dot (lazy solution)
  if [[ ${tag} == *"."* ]]; then
    tag=`echo ${tag} | cut -d"." -f1`
  fi

  echo ${tag}
}

function task_id {
  func=${1}
  task=`get_id ${func} task`
  echo $task
}

function run_id {
  func=${1}
  run=`get_id ${func} run`
  echo $run
}

#start_ssh client
function start_ssh {
  # start the ssh-agent in the background
  eval $(ssh-agent -s)
  # Add a private key to SSH.
  if [ -f ${SSH_KEY} ]; then
    ssh-add ${SSH_KEY}
    ssh -T git@github.com
  else
    echo "${SSH_KEY} key not found! Confirm file exists or set SSH_KEY variable in ~/.bash_profile"
  fi
}

function check_function {
  FN=`type -t $1`

  if [[ -z ${FN} ]]; then
    echo 1
  else
    echo 0
  fi
}

detect_scheduler() {
  if command -v qsub >/dev/null 2>&1; then
    echo "soge"
  elif command -v sbatch >/dev/null 2>&1; then
    echo "slurm"
  else
    echo "Error: Neither SoGE (qsub) nor SLURM (sbatch) detected. Remove --sge flag from call" >&2
    return 1
  fi
}

# Function to wait for a submitted job (supports both qsub (SGE) and sbatch (SLURM))
function wait_for_job {

  if [[ $# -eq 0 ]]; then
    echo
    print_line -
    echo "wait_for_job"
    echo
    echo "This function waits until the execution of a submitted job has finished before continuing."
    echo
    echo "Usage:"
    echo "  wait_for_job <job_name>"
    echo
    echo "Examples:"
    echo "  wait_for_job \"sub-003_all\"    # waits for job 'sub-003_all' to finish (SGE or SLURM)"
    print_line -
    echo
    return
  fi

  JOB_NAME="$1"

  # Detect scheduler: SGE/qsub or SLURM/sbatch
  system=$(detect_scheduler) || return 1  # Detect scheduler and exit on error

  # Handle job waiting for SGE (qsub)
  if [[ "${system}" == "soge" ]]; then
    # Find job ID based on job name
    JOB_ID=$(qstat | grep -m1 -F "${JOB_NAME}" | awk '{print $1}')
    
    if [[ -z "${JOB_ID}" ]]; then
      echo "ERROR: Could not find job '${JOB_NAME}' in SGE queue!"
      return 1
    fi

    echo "Waiting for SGE job '${JOB_NAME}' (ID: ${JOB_ID}) to finish..."
    while qstat -u "$(whoami)" | awk '$1 == '"${JOB_ID}"'' | grep -q .; do
      sleep 10  # Check every 10 seconds
    done
    echo "SGE Job '${JOB_NAME}' finished."

  # Handle job waiting for SLURM (sbatch)
  elif [[ "${system}" == "slurm" ]]; then
    # Find job ID based on job name
    JOB_ID=$(squeue --name="${JOB_NAME}" --format="%A" | tail -n 1)

    if [[ -z "${JOB_ID}" || "${JOB_ID}" == "JOBID" ]]; then
      echo "ERROR: Could not find job '${JOB_NAME}' in SLURM queue!"
      return 1
    fi

    echo "Waiting for SLURM job '${JOB_NAME}' (ID: ${JOB_ID}) to finish..."
    while squeue -u "$(whoami)" --job "${JOB_ID}" | grep -q "${JOB_ID}"; do
      sleep 10  # Check every 10 seconds
    done
    echo "SLURM Job '${JOB_NAME}' finished."
  fi
}


# function to fetch the module number given a string. Easy if you do remember the name of the process, but not
# the associated module number
function get_module_nr() {

  if [[ $# -eq 0 ]]; then
    echo "NEED AT LEAST ONE ARGUMENT!"
    echo
    print_line -
    echo "get_module_nr"
    echo
    echo "Function to get the module number given an input string. It reads the help-text of the master script"
    echo "in REPO_DIR/misc/modules.txt and looks for the module corresponding to the input string. I have this"
    echo "because module numbers tend to change and I don't feel like looking that up every time.."
    echo
    echo "The more specific you are with your string, the more stable the result will be. Important is that the"
    echo "format as specified in the master-script is maintained. This is because it looks for the leading semi-"
    echo "colon and certain spaces. So if you add modules to the help text, use the format that you see in there!"
    echo
    echo "Usage"
    echo "  get_module_nr <string1>"
    echo
    echo "Examples"
    echo "  get_module_nr \"spinoza_fmriprep\"    > fetches the module number of fmriprep"
    echo "  get_module_nr \"spinoza_freesurfer\"  > fetches the module number of freesurfer"
    print_line -
    echo
  else
    # Path to the modules.txt file
    modules_txt="${REPO_DIR}/misc/modules.txt"

    # Read file safely (works on macOS and Linux)
    if [[ ! -f "$modules_txt" ]]; then
      echo "Error: Modules file not found at $modules_txt" >&2
      return 1
    fi

    # Process file to extract module numbers that match the search string(s)
    mods=$(grep "$1" "$modules_txt" | awk '{print $1}' | cut -d"-" -f2 | cut -d':' -f1)

    # Sort and return results (space-separated)
    if [[ -n "$mods" ]]; then
      echo "$mods" | sort | tr '\n' ' '
      echo
    else
      echo "No matching module found for \"$1\"" >&2
      return 1
    fi
  fi
}

# get extension from file
function fetch_extension {
  fname=$(basename -- "${1}")
  ext="${fname##*.}"
  filename="${fname%.*}"
  echo $ext
}

# function to get whole file path
function fetch_filepath {

  # if file specified is in current directory, add entire path
  if [[ `echo ${1:0:1}` != "/" ]]; then
    INPUT=$(readlink -f "${1}")
  else
    INPUT=${1}
  fi

  echo ${INPUT}
}

#-----------------------------------------------------------------------------
# Define function to call matlab given a script
function call_matlab {
  if [[ $# -ne 1 ]]; then
    echo "Received 0 arguments, need the path to the MATLAB script"
    echo
    print_line -
    echo "call_matlab"
    echo
    echo "Wrapper to call MATLAB from the command line. It'll need a full path to the script and will read"
    echo "from the SKIP_LINES variable how many lines should be skipped during start-up. Seeing all those"
    echo "modules that are added is rather redundant."
    echo
    echo "Usage:"
    echo "  call_matlab <string_to_matlab_script>"
    echo
    echo "Examples:"
    echo "  call_matlab /path/to/my/matlab_script.m"
    print_line -
    echo
    return 1
  fi

  # Check if SKIP_LINES is set; otherwise, default to 0
  local skip_lines=${SKIP_LINES:-0}

  # Fetch the absolute path of the MATLAB script
  local MATLAB_SCRIPT=$(fetch_filepath "${1}")
  
  # Check if MATLAB_CMD contains 'spm_mcr' or 'run_spm12.sh'
  if [[ "${MATLAB_CMD}" == *"spm_mcr"* ]] || [[ "${MATLAB_CMD}" == *"run_spm12.sh"* ]]; then
    # If using MCR, do NOT modify the path
    echo "Running with MCR command: ${MATLAB_CMD}"
    
    # Save the current LD_LIBRARY_PATH
    local OLD_LD_LIBRARY_PATH="$LD_LIBRARY_PATH"

    # add the libraries
    export PATH=$MCRROOT/bin:$PATH
    export LD_LIBRARY_PATH=$MCRROOT/runtime/glnxa64:$MCRROOT/bin/glnxa64:$MCRROOT/sys/os/glnxa64
    ${MATLAB_CMD} "${MATLAB_SCRIPT}" | tail -n +${skip_lines}

    # unset LD_LIBRARY_PATH
     export LD_LIBRARY_PATH="$OLD_LD_LIBRARY_PATH"

  else
    # If using standard MATLAB, add path and execute
    ${MATLAB_CMD} "addpath('$(dirname "${MATLAB_SCRIPT}")'); $(basename "${MATLAB_SCRIPT}" .m); quit" | tail -n +${skip_lines}
  fi

  # Check exit status and return appropriately
  if [[ $? -ne 0 ]]; then
    return 1
  fi
}

#-----------------------------------------------------------------------------
# SANLM script
function make_sanlm_script {

  if [[ $# -ne 3 ]]; then
    echo "Received only ${#} arguments, need 3:"
    count=0; for ii in "${@}"; do ((count++)); echo " ${count}.) ${ii}"; done
    echo
    print_line -
    echo "make_sanlm_script"
    echo
    echo "Make a matlab script to be called with call_matlab to denoise your images with the SANLM-filter".
    echo "This spatial-adaptive Non-Local Means (SANLM) is a denoising filter and removes noise while maintai-"
    echo "ning edges, making this more suited than Gaussian filtering methods that blur the images."
    echo ""
    echo "The NL-means filter (7) restores every pixel in the image by computing a weighted average of sur-"
    echo "rounding pixels using a robust similarity measure that takes into account the neighboring pixels sur-"
    echo "rounding the pixel being compared. The most important parameter for NL-means denoising is h2, which "
    echo "regulates the smoothing strength. The optimum value of this parameter has been experimentally esti-"
    echo "mated to be σ2 for the block-based NL-means version, σ being the noise standard deviation"
    echo "module that are added is rather redundant."
    echo "See: https://onlinelibrary.wiley.com/doi/10.1002/jmri.22003"
    echo ""
    echo "Args:"
    echo "  <spm_path>  path to the desired SPM-installation"
    echo "  <input>     input image (gunzip'ed nii-file)"
    echo "  <script>    script name"
    echo ""
    echo "Usage:"
    echo "  make_sanlm_script <path/to/spm12> <anat.nii> <string_to_matlab_script>"
    echo
    echo "Examples:"
    echo "  make_sanlm_script /usr/bin/spm12 anat.nii.gz /path/to/my/matlab_script.m"
    print_line -
    echo
  else  

    (
    echo "%-----------------------------------------------------------------------------"
    echo "% Created on `date`. SANLM-filtering with CAT12"
    echo ""
    echo "clear;"

    # deal with MCR
    if [[ "${MATLAB_CMD}" == *"spm_mcr"* ]] || [[ "${MATLAB_CMD}" == *"run_spm12.sh"* ]]; then
      echo ""
    else
      echo "addpath(genpath('${1}'));"
    fi
    
    echo "matlabbatch{1}.spm.tools.cat.tools.sanlm.data = {'${2},1'};"
    echo "matlabbatch{1}.spm.tools.cat.tools.sanlm.prefix = 'sanlm_';"
    echo "matlabbatch{1}.spm.tools.cat.tools.sanlm.NCstr = Inf;"
    echo "matlabbatch{1}.spm.tools.cat.tools.sanlm.rician = 0;"
    echo ""
    echo "spm_jobman('initcfg');"
    echo "spm('defaults','fMRI')"
    echo "spm_jobman('run', matlabbatch);"
    echo "exit"
    ) >> ${3}

  fi

}

#-----------------------------------------------------------------------------
# SUIT SCRIPT
function make_suit_script {

  if [[ $# -ne 3 ]]; then
    echo "Received only ${#} arguments, need 3:"
    count=0; for ii in "${@}"; do ((count++)); echo " ${count}.) ${ii}"; done
    echo
    print_line -
    echo "make_suit_script"
    echo
    echo "Make a matlab script to be called with call_matlab to segment the cerebellum".
    echo ""
    echo "Args:"
    echo "  <spm_path>  path to the desired SPM-installation"
    echo "  <input>     input image (gunzip'ed nii-file)"
    echo "  <script>    script name"
    echo ""
    echo "Usage:"
    echo "  make_suit_script <path/to/spm12> <anat.nii> <string_to_matlab_script>"
    echo
    echo "Examples:"
    echo "  make_suit_script /usr/bin/spm12 anat.nii /path/to/my/matlab_script.m"
    print_line -
    echo
  else

    (
    echo "%-----------------------------------------------------------------------------"
    echo "% Created on `date`. Cerebellum segmentation with SUIT"
    echo ""
    echo "clear;"
    
    # deal with MCR
    if [[ "${MATLAB_CMD}" == *"spm_mcr"* ]] || [[ "${MATLAB_CMD}" == *"run_spm12.sh"* ]]; then
      echo ""
    else
      echo "addpath(genpath('${1}'));"
    fi

    echo "matlabbatch{1}.spm.tools.suit.isolate_seg.source = {{'${2},1'}};"
    echo "matlabbatch{1}.spm.tools.suit.isolate_seg.bb = [-76 76"
    echo "                                                -108 -6"
    echo "                                                -70 11];"
    echo "matlabbatch{1}.spm.tools.suit.isolate_seg.maskp = 0.2;"
    echo "matlabbatch{1}.spm.tools.suit.isolate_seg.keeptempfiles = 1;"
    echo ""
    echo "spm_jobman('initcfg');"
    echo "spm('defaults','fMRI')"
    echo "spm_jobman('run', matlabbatch);"
    echo "exit"
    ) >> ${3}
  fi

}

#-----------------------------------------------------------------------------
# NORDIC SCRIPT
function make_nordic_script {
  if [[ $# -ne 5 ]]; then
    echo "Received only ${#} arguments, need 4:"
    count=0; for ii in "${@}"; do ((count++)); echo " ${count}.) ${ii}"; done
    echo
    print_line -
    echo "make_nordic_script"
    echo
    echo "Make a matlab script to be called with call_matlab to run NORDIC. If you want to change the mode to"
    echo "\"magnitude-only\", set the \"ARG.magnitude_only\" to 1. Default = [], which includes the phase data."
    echo ""
    echo "Args:"
    echo "  <magnitude> path to magnitude image of fMRI-acquisition"
    echo "  <phase>     path to phase image of fMRI-acquisition"
    echo "  <output>    path to NORDIC'ed output"
    echo "  <mag_only>  1 for magnitude only; [] for magnitude & phase"
    echo "  <script>    script name"
    echo ""
    echo "Usage:"
    echo "  make_nordic_script <mag> <phase> <output> <script>"
    echo
    echo "Examples:"
    echo "  make_nordic_script mag.nii.gz phase.nii.gz nordic.nii.gz nordic.m"
    print_line -
    echo
  else  

    (
    echo "%-----------------------------------------------------------------------------"
    echo "% Created on `date`. Nordic on $(basename ${1})"
    echo ""
    echo "clear;"
    echo "addpath(genpath('${REPO_DIR}/misc'));"
    echo "ARG.DIROUT              = '$(dirname ${3})/';"
    # echo "ARG.temporal_phase      = 1;"
    # echo "ARG.phase_filter_width  = 10;"
    echo "ARG.magnitude_only      = ${4};"
    echo ""
    echo "nordic_template('${1}', '${2}', '$(basename ${3})', ARG);"
    echo ""
    echo "exit;"
    ) >> ${5}

  fi

}

#-----------------------------------------------------------------------------
# ANTs RF SCRIPT (MNI>FSAverage)
function make_antsrf_script {
  function Usage {
    cat <<USAGE

---------------------------------------------------------------------------------------------------
make_antsrf_script

Follow workflow https://mumfordbrainstats.tumblr.com/post/166054797696/feat-registration-workaround
To use fMRIprep output in FEAT. Uses the mean of the functional run as 'standard', rather than the
MNI152-image.

Args:
  <input>        input file that needs to be warped
  <interp>       interpolation method (linear or nearest, default is linear)
  <output dir>   output directory (defaults to SUBJECTS_DIR/fsaverage/surf)
  <basename>     output basename (defaults to 'mni2fsaverage')
  <script>       name for the script

Example:
  make_antsrf_script zstats1.nii.gz "linear" some/dir desc-zstats1 sub-01_ses-1_desc-antsrf.m

---------------------------------------------------------------------------------------------------

USAGE
}

  in_file=$(readlink -f "${1}")
  interp=${2}
  output_dir=${3}
  base_name=${4}
  script_name=${5}
  
  if [[ ${HELP} -eq 1 || $# -lt 5 ]]; then
    Usage >&2
  else

    # set default output directory
    if [[ -z ${output_dir} ]]; then
      output_dir=${FS}/fsaverage/surf
    fi

    # create it if it doesn't exit
    if [[ ! -d ${output_dir} ]]; then
      mkdir -p ${output_dir}
    fi

    # set default basename
    if [[ -z ${base_name} ]]; then
      base_name="mni2fsaverage"
    fi

    # set default basename
    if [[ -z ${script_name} ]]; then
      script_name=$(dirname ${in_file})/$(basename ${in_file} .nii.gz).m
    fi

    # output files
    lh_output=${output_dir}/lh.${base_name}.nii.gz
    rh_output=${output_dir}/rh.${base_name}.nii.gz

    (
    echo "%-----------------------------------------------------------------------------"
    echo "% Created on `date`. Projecting $(basename ${in_file}) to FSAverage"
    echo ""
    echo "clear;"
    echo "addpath(genpath('${REPO_DIR}/misc'));"
    echo "lh_map = '${REPO_DIR}/misc/CBIG_lh.avgMapping_allSub_RF_ANTs_MNI152_orig_to_fsaverage.mat';"
    echo "rh_map = '${REPO_DIR}/misc/CBIG_rh.avgMapping_allSub_RF_ANTs_MNI152_orig_to_fsaverage.mat';"
    echo "input = MRIread('${in_file}');"
    echo "[lh_proj_data, rh_proj_data] = CBIG_RF_projectMNI2fsaverage('${in_file}', '${interp}', lh_map, rh_map);"
    echo ""
    echo "input.vol = permute(lh_proj_data, [4 2 3 1]);"
    echo "MRIwrite(input, '${lh_output}');"
    echo "input.vol = permute(rh_proj_data, [4 2 3 1]);"
    echo "MRIwrite(input, '${rh_output}');"
    echo ""
    echo "exit;"
    ) >> ${script_name}

  fi

}

#-----------------------------------------------------------------------------
# Define function to create SPM-compatible script with
function make_bias_script {

  if [[ $# -ne 3 ]]; then
    echo "Received only ${#} arguments, need 3:"
    count=0; for ii in "${@}"; do ((count++)); echo " ${count}.) ${ii}"; done
    echo
    print_line -
    echo "make_bias_script"
    echo
    echo "Make a matlab script to be called with call_matlab to bias correct your image with SPM".
    echo "Uses: \"${REPO_DIR}/misc/spm_batch_bias.m\"."
    echo "This file can be changed according to your needs."
    echo ""
    echo "Args:"
    echo "  <spm_path>  path to the desired SPM-installation"
    echo "  <input>     input image (gunzip'ed nii-file)"
    echo "  <script>    script name"
    echo ""
    echo "Usage:"
    echo "  make_bias_script <path/to/spm12> <anat.nii> <string_to_matlab_script>"
    echo
    echo "Examples:"
    echo "  make_bias_script /usr/bin/spm12 anat.nii /path/to/my/matlab_script.m"
    print_line -
    echo
  else
    (
    echo "%-----------------------------------------------------------------------------"
    echo "% Created on `date`. Bias field correction with SPM12"
    echo ""
    echo "clear;"

    # deal with MCR
    if [[ "${MATLAB_CMD}" == *"spm_mcr"* ]] || [[ "${MATLAB_CMD}" == *"run_spm12.sh"* ]]; then
      echo ""
    else
      echo "addpath(genpath('${1}'));"
    fi
    ) >> "${3}"

    batch_file="${REPO_DIR}/misc/spm_batch_bias.m"
    cat "${batch_file}" >> "${3}"
    call_replace CHANGE_THIS_SPM_PATH "${1}" "${3}"
    call_replace CHANGE_THIS_INPUT "${2}" "${3}"

    (
    echo ""
    echo "spm_jobman('initcfg');"
    echo "spm('defaults','fMRI')"
    echo "spm_jobman('run', matlabbatch);"
    echo "exit"
    ) >> ${3}
  fi
}


#-----------------------------------------------------------------------------
# PHYSIO SCRIPT
function make_physio_script {

  if [[ $# -ne 8 ]]; then
    echo "Received only ${#} arguments, need 8:"
    count=0; for ii in "${@}"; do ((count++)); echo " ${count}.) ${ii}"; done
    echo
    print_line -
    echo "make_physio_script"
    echo ""
    echo "Make a matlab script to be called with call_matlab to create regressor files from your physio recor-"
    echo "dings from the scanner using the PhysIO-toolbox as part of TAPAS"
    echo ""
    echo "Args:"
    echo "  <spm_path>  (1) path to the desired SPM-installation"
    echo "  <input>     (2) input file; assumed to be the output from \"scanphyslog2bids\" (.tsv.gz-file)"
    echo "  <tr>        (3) repetition time of acquisition"
    echo "  <volumes>   (4) number of volumes in the functional run"
    echo "  <output>    (5) directory+basename for output files (extensions will be appended)"
    echo "  <dummies>   (6) number of dummy volumes"
    echo "  <n_slices>  (7) number of slices in the volume"
    echo "  <script>    (8) script name"
    echo ""
    echo "Usage:"
    echo "  make_physio_script <path/to/spm12> <physio.tsv.gz> <tr> <volumes> <output> <string_to_matlab_script>"
    echo ""
    echo "Examples:"
    echo "  make_physio_script /usr/bin/spm12 anat.nii 0.105 3200 regressors /path/to/my/matlab_script.m"
    print_line -
    echo
  else

    local spm_path="${1}"
    local input_file="${2}"
    local tr=${3}
    local vols=${4}
    local output="${5}"
    local dummies=${6}
    local n_slices=${7}
    local job_name="${8}"

    ext=`fetch_extension "${input_file}"`
    if [[ ${ext,,} == "log" ]]; then
      vendor="philips"
    else
      vendor="BIDS"
    fi

    (
    echo "%-----------------------------------------------------------------------------"
    echo "% Created on `date`. Create PhysIO regressors from SCANPHYSLOG"
    echo ""
    echo "clear;"

    # deal with MCR
    if [[ "${MATLAB_CMD}" == *"spm_mcr"* ]] || [[ "${MATLAB_CMD}" == *"run_spm12.sh"* ]]; then
      echo ""
    else
      echo "addpath(genpath('${spm_path}'));"
    fi
    ) >> "${job_name}"

    batch_file=${REPO_DIR}/misc/spm_batch_phys.m
    cat "${batch_file}" >> "${job_name}"

    call_replace CHANGE_THIS_INPUT "${input_file}" "${job_name}"
    call_replace CHANGE_THIS_VENDOR "${vendor}" "${job_name}"
    call_replace CHANGE_THIS_N_SLICES ${n_slices} "${job_name}"
    call_replace CHANGE_THIS_TR ${tr} "${job_name}"
    call_replace CHANGE_THIS_N_DUMMIES ${dummies} "${job_name}"
    call_replace CHANGE_THIS_N_VOLS ${vols} "${job_name}"
    call_replace CHANGE_THIS_OUTPUT ${output} "${job_name}"

    (
    echo ""
    echo "spm_jobman('initcfg');"
    echo "spm('defaults','fMRI')"
    echo "spm_jobman('run', matlabbatch);"
    echo "exit"
    ) >> "${job_name}"

    cat "${job_name}" | grep -A0 "matlabbatch{" >> $(dirname "${job_name}")/$(basename "${job_name}" .m)_batch.m

  fi
  
}

#-----------------------------------------------------------------------------
# SPM BRAIN MASK SCRIPT
function make_mask_script {

  if [[ $# -ne 4 ]]; then
    echo "Received only ${#} arguments, need 3:"
    count=0; for ii in "${@}"; do ((count++)); echo " ${count}.) ${ii}"; done
    echo
    print_line -
    echo "make_mask_script"
    echo
    echo "Make a matlab script to be called with call_matlab to create a brain mask from the INV2 image"
    echo ""
    echo "Args:"
    echo "  <spm_path>  path to the desired SPM-installation"
    echo "  <input>     input image (gunzip'ed nii-file), generally the INV2 image of an MP2RAGE sequence"
    echo "  <output>    output image (mask)"
    echo "  <script>    script name"
    echo ""
    echo "Usage:"
    echo "  make_mask_script <path/to/spm12> <inv2.nii> <string_to_matlab_script>"
    echo
    echo "Examples:"
    echo "  make_mask_script /usr/bin/spm12 inv2.nii /path/to/my/matlab_script.m"
    print_line -
    echo
  else

    (
    echo "%-----------------------------------------------------------------------------"
    echo "% Created on `date`. Running with ${VER}"
    echo ""
    echo "clear;"
    echo ""
    ) >> "${4}"

    # echo to file
    batch_file=${REPO_DIR}/misc/spmBrainMask_spm12_job.m
    cat "${batch_file}" >> "${4}"

    # perl is agnostic to MacOS/Linux
    call_replace CHANGE_THIS_SPM_PATH "${1}" "${4}"
    call_replace CHANGE_THIS_INPUT "${2}" "${4}"
    call_replace CHANGE_THIS_OUTPUT "${3}" "${4}"

    (
    echo ""
    echo "spm_jobman('initcfg');"
    echo "spm('defaults','fMRI')"
    echo "spm_jobman('serial', matlabbatch);"
    echo "exit"
    ) >> "${4}"
    
  fi
}

#-----------------------------------------------------------------------------
# CAT12 SCRIPT
function make_cat_script {
  if [[ $# -ne 4 ]]; then
    echo "Received only ${#} arguments, need 4:"
    count=0; for ii in "${@}"; do ((count++)); echo " ${count}.) ${ii}"; done
    echo
    print_line -
    echo "make_cat_script"
    echo
    echo "Make a matlab script to be called with call_matlab to segment your anatomical file with CAT12. Can"
    echo "also do denoising and stuff, but better and more conservative to do this with call_spmsanlm"
    echo ""
    echo "Args:"
    echo "  <spm_path>  path to the desired SPM-installation"
    echo "  <input>     input image (gunzip'ed nii-file)"
    echo "  <mode>      \"brain\" for just segmentations; \"full\" for intensity normalization & SANLM-filtering"
    echo "  <script>    script name"
    echo ""
    echo "Usage:"
    echo "  make_cat_script <path/to/spm12> <anat.nii> <mode> <string_to_matlab_script>"
    echo
    echo "Examples:"
    echo "  make_cat_script /usr/bin/spm12 anat.nii brain /path/to/my/matlab_script.m"
    print_line -
    echo
  else

    # find cat directory
    cat12_dir=`find -L ${1} -type d -name "*cat12*" -print -quit 2>/dev/null`
    if [[ -z ${cat12_dir} ]]; then
      echo "Could not find CAT12-directory in \"${1}\""
      exit 1
    fi

    # Check if we have compatible version; we're using 12.6!!

    VER=`cat ${cat12_dir}/Contents.txt | grep Version | cut -d" " -f3 2>/dev/null`
    ACCEPTED_VERSIONS=("1113" "1450" "2043" "2170" "2556" "2557")
    if [[ ! -f "${REPO_DIR}/misc/cat_batch_custom.m" ]]; then
      if [[ " ${ACCEPTED_VERSIONS[*]} " =~ " ${VER} " ]]; then
        batch_file=${REPO_DIR}/misc/cat_batch_r${VER}.m
      else
        echo "CAT12 VERSION = ${VER}.. Accepted versions are: "
        for i in ${ACCEPTED_VERSIONS[@]}; do echo $i; done
        echo
        echo "If you have a different version, use the CAT12 GUI to generate a matlabbatch file"
        echo "See \"${REPO_DIR}/misc/cat_batch_r2556.m\" for an example"
        echo "Use the \"view .m code\" option and save the file as \"${REPO_DIR}/misc/cat_batch_custom.m\""
        echo "Ensure that all variables starting with \"CHANGE_*\" have the same format!"
        exit 1
      fi
    else
      batch_file=${REPO_DIR}/misc/cat_batch_custom.m
      echo "Using custom batch-file: \"${batch_file}\""
    fi

    if [[ ! -f ${batch_file} ]]; then
      echo "ERROR: could not find batch file for version=${VER}. Please create \"${batch_file}\" or use CAT-version:"
      for i in ${ACCEPTED_VERSIONS[@]}; do echo $i; done
      exit 1
    fi

    tpm_dir=`find -L ${1} -type d -name "*tpm*" -print -quit 2>/dev/null`
    if [[ -z ${tpm_dir} ]]; then
      echo "Could not find template-directory in \"${1}\""
      exit 1
    fi

    (
    echo "%-----------------------------------------------------------------------------"
    echo "% Created on `date`. Running with ${VER}"
    echo ""
    echo "clear;"

    # deal with MCR
    if [[ "${MATLAB_CMD}" == *"spm_mcr"* ]] || [[ "${MATLAB_CMD}" == *"run_spm12.sh"* ]]; then
      echo ""
    else
      echo "addpath(genpath('${1}'));"
    fi
    
    ) >> ${4}

    if [[ ${3} == 'brain' ]]; then
      echo "Turning off bias/intensity correction & sanlm-filtering"
      bias_str=2.2204e-16 # ultralight
      bias_reg=0.01       # ultralight
      bias_fhwm=90        # ultralight
      app=0               # none
      sanlm=0             # none
    else
      bias_str=0.25       # light
      bias_reg=0.001      # medium
      bias_fhwm=60        # medium
      app=1070            # default
      sanlm=1             # classic
    fi

    # echo to file
    cat "${batch_file}" >> ${4}

    # # change parameters (perl is agnostic to MacOS/Linux)
    call_replace CHANGE_THIS_SPM_PATH "${1}" ${4}
    call_replace CHANGE_THIS_INPUT "${2}" ${4}
    call_replace CHANGE_BIAS_STR "${bias_str}" ${4}
    call_replace CHANGE_BIAS_REG "${bias_reg}" ${4}
    call_replace CHANGE_BIAS_FWHM "${bias_fhwm}" ${4}
    call_replace CHANGE_THIS_APP_TERM "${app}" ${4}
    call_replace CHANGE_THIS_SANLM_TERM "${sanlm}" ${4}

    (
    echo ""
    echo "cat_get_defaults('extopts.expertgui',1);"
    echo "spm_jobman('initcfg');"
    echo "spm('defaults','fMRI')"
    echo "spm_jobman('run', matlabbatch);"
    echo "exit"
    ) >> ${4}

    # also save the matlabbatch-only lines to a file that we can load in SPM/CAT12
    if [[ -f $(dirname ${4})/$(basename ${4} .m)_batch.m ]]; then
      rm $(dirname ${4})/$(basename ${4} .m)_batch.m
    fi

    cat ${4} | grep -A0 "matlabbatch{" >> $(dirname ${4})/$(basename ${4} .m)_batch.m
  fi
}
