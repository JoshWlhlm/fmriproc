#!/usr/bin/env bash

#---------------------------------------------------------------------------------------------------------
# check if there's is a setup file containing the major paths and source it if it exists
source "${SETUP_FILE}"
source call_bashhelper

#---------------------------------------------------------------------------------------------------------
# Create help text
function Usage {
    cat <<USAGE

---------------------------------------------------------------------------------------------------
spinoza_lsprep

wrapper for call_lsprep that performs the reconstruction of the line data. Uses MRecon, so we can
only run it on the spinoza cluster. It calls upon call_lsprep, which internally uses a template
for the reconstruction with MRecon based on scripts provided by Luisa Raimondo.

Usage:
  spinoza_lsprep [options] <project root directory> <sourcedata>

Arguments:
  -s <subject>        subject ID (e.g., 01). Can also be comma-separated list: 01,02,05
  -n <session>        session ID (e.g., "2,3" or "3"). Defaults to '2'; specify multiple 
                      sessions in a comma-separated list: "2,3,4"
  -j <n_cpus>         number of CPUs to use (default = 1)
  -q <queue>          submit jobs to a specific queue. Defaults to SGE_QUEUE_LONG in spinoza_setup
  -x <kwargs>         Additional commands to be passed to 'call_lsprep'. Format should
                      be comma-separated flags as follows: 
                        - if you specify a flag and values | <flag>=<value>
                        - if you specify a flag only | <flag>

                      combine as:
                      "-x <flag1>=<value>,<flag2>,<flag3>,<flag4>=<value>"

                      This allows bash commands to be translated to python commands

  -c|--sge            submit job to cluster (SGE/SLURM)
  <project root>      base directory containing the derivatives and the subject's folders.
  <derivatives>       base directory to store the 'lsprep'-folder in 

Eample:
  spinoza_lsprep -s 001 -n 3 --sge DIR_DATA_SOURCE DIR_DATA_DERIV
  spinoza_lsprep -s 001 -n 3 -x --filter-pca=0.18,--verbose DIR_DATA_SOURCE DIR_DATA_DERIV

run with master:  
  "master -m 03b -s 008 -n 3" # use all defaults from call_lsprep
  "master -m 03b -s 008 -n 3 -x --filter-pca=0.18,--verbose,--no-button,--ow,--ica" # customize
  "master -m 03b -s 008 -n 3 --sge -x --filter-pca=0.18,--verbose,--ica" # customize # submit

---------------------------------------------------------------------------------------------------

USAGE
    exit 1
}

if [[ $# -lt 2 ]] ; then
  Usage >&2
  exit 1
fi

# Check for subject & session flags
OW=0
run_local=1
SGE_QUEUE=${SGE_QUEUE_SHORT}
while getopts :-:cs:n:q:x:j: argument
do
  case ${argument} in
    -)
      case "${OPTARG}" in      
        sge)
          run_local=0
          ;;                                                                        
        *)
          if [ "$OPTERR" = 1 ] && [ "${optspec:0:1}" != ":" ]; then
            echo "Unknown option --${OPTARG}"
            exit 1
          fi
          ;;
      esac;;    
    s)  sub=${OPTARG}
          ;;
    n)  ses=${OPTARG}
          ;;
    c)  SGE=1
          ;;   
    j)  n_cpus=${OPTARG}
          ;;
    q)  SGE_QUEUE=${OPTARG}
          ;;          
    x)  LSPREP_KWARGS=${OPTARG}
          ;;                               
  esac
done

INPUT=${@:$OPTIND:1}
OUTPUT=${@:$OPTIND+1:1}

#-----------------------------------------------------------------------------
# sort subjects

if [[ -z ${sub} ]]; then
  # loop through subjects
  search="${INPUT}/${SUBJECT_PREFIX}*"
else
  # read specified subjects into array
  IFS=', ' read -r -a search <<< "${sub}"
  search=${search[@]}
  unset IFS
fi

if [[ -z ${ses} ]]; then
  # loop through subjects
  ses_ids=("2")
else
  # read specified subjects into array
  IFS=', ' read -r -a ses_ids <<< "${ses}"
  ses_ids=${ses_ids[@]}
  unset IFS
fi

if [[ ${run_local} -eq 0 ]]; then
  if [[ -z ${n_cpus} ]]; then
    n_cpus=1
  fi

  if [ ! -d ${DIR_LOGS} ]; then
    mkdir -p ${DIR_LOGS}
  fi
else
  if [[ -z ${n_cpus} ]]; then
    n_cpus=1
  fi
fi

#-----------------------------------------------------------------------------
# intro
start_timer "Preprocessing of line-scanning data with LSprep"

#-----------------------------------------------------------------------------
# Run it

for subID in ${search}; do

  # collect subject name
  sub_name=$(collect_subject_name "$sub" "$subID" "$SUBJECT_PREFIX")

  # parse kwargs
  if [[ ! -z ${LSPREP_KWARGS} ]]; then
    LSPREP_KWARGS=$(echo ${LSPREP_KWARGS} | tr '=' ' ' | tr ',' ' ')
  fi

  if [[ ${run_local} -eq 1 ]]; then
    # print header
    print_subject_header ${sub_name}
  fi

  # loop through sessions
  for s_id in ${ses_ids}; do
    
    base=${sub_name}_ses-${s_id}

    # define log file
    log_file=${OUTPUT}/lsprep/${sub_name}/${sub_name}_ses-${s_id}_desc-preproc_bold.log
    if [[ ! -d $(dirname ${log_file}) ]]; then
      mkdir -p $(dirname ${log_file})
    fi

    # decide job execution
    if [[ ${run_local} -eq 0 ]]; then
      if [[ ! -z ${SGE_QUEUE} ]]; then
        QUEUE=${SGE_QUEUE}
      else
        QUEUE=${SGE_QUEUE_SHORT}
      fi
      submit=$(generate_submission_command ${QUEUE} ${n_cpus} ${base}_desc-lsprep ${log_file})
      call_=$(which call_lsprep)
      job="${submit} ${call_}"
    else
      job="call_lsprep"
    fi

    # decide the job type
    job="$(decide_job_type "call_lsprep" "${base}_desc-lsprep" "${run_local}" "${log_file}" "${n_cpus}" "${SGE_QUEUE}")"

    # define command
    cmd="""${job} \
      -s sub-${subID} \
      -n ${s_id} \
      ${LSPREP_KWARGS}"""

    # echo command
    if [[ ${run_local} -eq 1 ]]; then
      print_cmd "${cmd}"
    fi

    (
      echo ""
      echo "### New invocation of call_lsprep @$(date)"
      echo "$(echo ${cmd} | xargs)"
      echo ""
    ) >> ${log_file}
    
    # execute cmd
    eval "${cmd}"

    if [[ $? -ne 0 ]]; then
      echo
      print_line -
      print_error_msg "$(basename ${0})" "$(basename ${cmd})"
      exit 1
    fi
  done

done

#-----------------------------------------------------------------------------
# outro
end_timer
